
EM_MAADI546.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000278a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  0000278a  0000281e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004a8  00800080  00800080  0000283e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000283e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002870  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b0  00000000  00000000  000028ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005c8c  00000000  00000000  00002e5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001603  00000000  00000000  00008ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000387b  00000000  00000000  0000a0eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000010c0  00000000  00000000  0000d968  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001c58  00000000  00000000  0000ea28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005300  00000000  00000000  00010680  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000560  00000000  00000000  00015980  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <__vector_1>
       8:	0c 94 c8 0f 	jmp	0x1f90	; 0x1f90 <__vector_2>
       c:	0c 94 ef 0f 	jmp	0x1fde	; 0x1fde <__vector_3>
      10:	0c 94 e0 10 	jmp	0x21c0	; 0x21c0 <__vector_4>
      14:	0c 94 b9 10 	jmp	0x2172	; 0x2172 <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 32 06 	jmp	0xc64	; 0xc64 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 70 10 	jmp	0x20e0	; 0x20e0 <__vector_10>
      2c:	0c 94 49 10 	jmp	0x2092	; 0x2092 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e8       	ldi	r30, 0x8A	; 138
      68:	f7 e2       	ldi	r31, 0x27	; 39
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a0 38       	cpi	r26, 0x80	; 128
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	a0 e8       	ldi	r26, 0x80	; 128
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 32       	cpi	r26, 0x28	; 40
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <main>
      8a:	0c 94 c3 13 	jmp	0x2786	; 0x2786 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <task3>:

void task3 (void)
{
	 u8 temperature ;
	 u8 current_preset_temp;
	 u8 temp = 0;
      92:	d0 e0       	ldi	r29, 0x00	; 0
	 
	while (1)
		{	
			current_preset_temp=EEPROM_voidRecieveDataFromEEPROM(0);
      94:	80 e0       	ldi	r24, 0x00	; 0
      96:	90 e0       	ldi	r25, 0x00	; 0
      98:	0e 94 14 0e 	call	0x1c28	; 0x1c28 <EEPROM_voidRecieveDataFromEEPROM>
			temperature=Average_Temp;
      9c:	c0 91 21 05 	lds	r28, 0x0521	; 0x800521 <Average_Temp>

				if (((temperature)  <= (current_preset_temp - 5)) || (temp==1))
      a0:	2c 2f       	mov	r18, r28
      a2:	30 e0       	ldi	r19, 0x00	; 0
      a4:	08 2f       	mov	r16, r24
      a6:	10 e0       	ldi	r17, 0x00	; 0
      a8:	a8 01       	movw	r20, r16
      aa:	45 50       	subi	r20, 0x05	; 5
      ac:	51 09       	sbc	r21, r1
      ae:	42 17       	cp	r20, r18
      b0:	53 07       	cpc	r21, r19
      b2:	14 f4       	brge	.+4      	; 0xb8 <task3+0x26>
      b4:	d1 30       	cpi	r29, 0x01	; 1
      b6:	81 f5       	brne	.+96     	; 0x118 <task3+0x86>
				{
					if ((temperature)  < (current_preset_temp + 4))
      b8:	a8 01       	movw	r20, r16
      ba:	4c 5f       	subi	r20, 0xFC	; 252
      bc:	5f 4f       	sbci	r21, 0xFF	; 255
      be:	24 17       	cp	r18, r20
      c0:	35 07       	cpc	r19, r21
      c2:	e4 f4       	brge	.+56     	; 0xfc <task3+0x6a>
					{
						temp=1;
						// Turn the heater on
						DIO_voidSetPinVal(DIO_PORTC,DIO_PIN2,HIGH);
      c4:	41 e0       	ldi	r20, 0x01	; 1
      c6:	62 e0       	ldi	r22, 0x02	; 2
      c8:	82 e0       	ldi	r24, 0x02	; 2
      ca:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
						DIO_voidSetPinVal(DIO_PORTC,DIO_PIN7,LOW);
      ce:	40 e0       	ldi	r20, 0x00	; 0
      d0:	67 e0       	ldi	r22, 0x07	; 7
      d2:	82 e0       	ldi	r24, 0x02	; 2
      d4:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
						// Red Led blinking while the heater is on
						if (Time_y==0) {DIO_voidSetPinVal(DIO_PORTC,DIO_PIN5,HIGH);}
      d8:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <Time_y>
      dc:	81 11       	cpse	r24, r1
      de:	07 c0       	rjmp	.+14     	; 0xee <task3+0x5c>
      e0:	41 e0       	ldi	r20, 0x01	; 1
      e2:	65 e0       	ldi	r22, 0x05	; 5
      e4:	82 e0       	ldi	r24, 0x02	; 2
      e6:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>

				if (((temperature)  <= (current_preset_temp - 5)) || (temp==1))
				{
					if ((temperature)  < (current_preset_temp + 4))
					{
						temp=1;
      ea:	d1 e0       	ldi	r29, 0x01	; 1
      ec:	15 c0       	rjmp	.+42     	; 0x118 <task3+0x86>
						// Turn the heater on
						DIO_voidSetPinVal(DIO_PORTC,DIO_PIN2,HIGH);
						DIO_voidSetPinVal(DIO_PORTC,DIO_PIN7,LOW);
						// Red Led blinking while the heater is on
						if (Time_y==0) {DIO_voidSetPinVal(DIO_PORTC,DIO_PIN5,HIGH);}
						else  		   {DIO_voidSetPinVal(DIO_PORTC,DIO_PIN5,LOW) ;}
      ee:	40 e0       	ldi	r20, 0x00	; 0
      f0:	65 e0       	ldi	r22, 0x05	; 5
      f2:	82 e0       	ldi	r24, 0x02	; 2
      f4:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>

				if (((temperature)  <= (current_preset_temp - 5)) || (temp==1))
				{
					if ((temperature)  < (current_preset_temp + 4))
					{
						temp=1;
      f8:	d1 e0       	ldi	r29, 0x01	; 1
      fa:	0e c0       	rjmp	.+28     	; 0x118 <task3+0x86>
						if (Time_y==0) {DIO_voidSetPinVal(DIO_PORTC,DIO_PIN5,HIGH);}
						else  		   {DIO_voidSetPinVal(DIO_PORTC,DIO_PIN5,LOW) ;}
						
					}
						
					else if ((temperature)  = (current_preset_temp + 4))
      fc:	c4 e0       	ldi	r28, 0x04	; 4
      fe:	c8 0f       	add	r28, r24
     100:	59 f0       	breq	.+22     	; 0x118 <task3+0x86>
					{
						temp=0;
						DIO_voidSetPinVal(DIO_PORTC,DIO_PIN2,LOW);
     102:	40 e0       	ldi	r20, 0x00	; 0
     104:	62 e0       	ldi	r22, 0x02	; 2
     106:	82 e0       	ldi	r24, 0x02	; 2
     108:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
						DIO_voidSetPinVal(DIO_PORTC,DIO_PIN5,LOW);
     10c:	40 e0       	ldi	r20, 0x00	; 0
     10e:	65 e0       	ldi	r22, 0x05	; 5
     110:	82 e0       	ldi	r24, 0x02	; 2
     112:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
						
					}
						
					else if ((temperature)  = (current_preset_temp + 4))
					{
						temp=0;
     116:	d0 e0       	ldi	r29, 0x00	; 0
						DIO_voidSetPinVal(DIO_PORTC,DIO_PIN2,LOW);
						DIO_voidSetPinVal(DIO_PORTC,DIO_PIN5,LOW);
					}
				}
				if ((temperature) >= (current_preset_temp + 5))
     118:	8c 2f       	mov	r24, r28
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	0b 5f       	subi	r16, 0xFB	; 251
     11e:	1f 4f       	sbci	r17, 0xFF	; 255
     120:	80 17       	cp	r24, r16
     122:	91 07       	cpc	r25, r17
     124:	cc f0       	brlt	.+50     	; 0x158 <task3+0xc6>
				{
					
					// Red led on but not blinking while cooling fan is on
					DIO_voidSetPinVal(DIO_PORTC,DIO_PIN5,HIGH);
     126:	41 e0       	ldi	r20, 0x01	; 1
     128:	65 e0       	ldi	r22, 0x05	; 5
     12a:	82 e0       	ldi	r24, 0x02	; 2
     12c:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
					// turn the heater off
					DIO_voidSetPinVal(DIO_PORTC,DIO_PIN2,LOW);
     130:	40 e0       	ldi	r20, 0x00	; 0
     132:	62 e0       	ldi	r22, 0x02	; 2
     134:	82 e0       	ldi	r24, 0x02	; 2
     136:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
					// turn the cooling fan on
					DIO_voidSetPinVal(DIO_PORTC,DIO_PIN7,HIGH);
     13a:	41 e0       	ldi	r20, 0x01	; 1
     13c:	67 e0       	ldi	r22, 0x07	; 7
     13e:	82 e0       	ldi	r24, 0x02	; 2
     140:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
					DIO_voidSetPinVal(DIO_PORTC,DIO_PIN4,LOW);
     144:	40 e0       	ldi	r20, 0x00	; 0
     146:	64 e0       	ldi	r22, 0x04	; 4
     148:	82 e0       	ldi	r24, 0x02	; 2
     14a:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
					DIO_voidSetPinVal(DIO_PORTC,DIO_PIN3,HIGH);
     14e:	41 e0       	ldi	r20, 0x01	; 1
     150:	63 e0       	ldi	r22, 0x03	; 3
     152:	82 e0       	ldi	r24, 0x02	; 2
     154:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
				}

			vTaskDelay(20);
     158:	84 e1       	ldi	r24, 0x14	; 20
     15a:	90 e0       	ldi	r25, 0x00	; 0
     15c:	0e 94 05 0c 	call	0x180a	; 0x180a <vTaskDelay>
		}
     160:	99 cf       	rjmp	.-206    	; 0x94 <task3+0x2>

00000162 <task4>:
{
	static u8 count = 0;
	
		while(1)
		{
			if ((DIO_u8ReadpinVal(DIO_PORTB,DIO_PIN0)==1) && count==0)
     162:	60 e0       	ldi	r22, 0x00	; 0
     164:	81 e0       	ldi	r24, 0x01	; 1
     166:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     16a:	81 30       	cpi	r24, 0x01	; 1
     16c:	71 f5       	brne	.+92     	; 0x1ca <task4+0x68>
     16e:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <count.2276>
     172:	81 11       	cpse	r24, r1
     174:	2a c0       	rjmp	.+84     	; 0x1ca <task4+0x68>
				{
					while(DIO_u8ReadpinVal(DIO_PORTB,DIO_PIN0)==1);
     176:	60 e0       	ldi	r22, 0x00	; 0
     178:	81 e0       	ldi	r24, 0x01	; 1
     17a:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     17e:	81 30       	cpi	r24, 0x01	; 1
     180:	d1 f3       	breq	.-12     	; 0x176 <task4+0x14>
					DIO_voidSetPinDir(DIO_PORTB,DIO_PIN1,OUTPUT); // SSD enable 1
     182:	41 e0       	ldi	r20, 0x01	; 1
     184:	61 e0       	ldi	r22, 0x01	; 1
     186:	81 e0       	ldi	r24, 0x01	; 1
     188:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
					DIO_voidSetPinDir(DIO_PORTB,DIO_PIN2,OUTPUT); // SSD enable 2
     18c:	41 e0       	ldi	r20, 0x01	; 1
     18e:	62 e0       	ldi	r22, 0x02	; 2
     190:	81 e0       	ldi	r24, 0x01	; 1
     192:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
					DIO_voidSetPinDir(DIO_PORTC,DIO_PIN2,OUTPUT); // heater relay
     196:	41 e0       	ldi	r20, 0x01	; 1
     198:	62 e0       	ldi	r22, 0x02	; 2
     19a:	82 e0       	ldi	r24, 0x02	; 2
     19c:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
					DIO_voidSetPinDir(DIO_PORTC,DIO_PIN7,OUTPUT); // cooling fan relay
     1a0:	41 e0       	ldi	r20, 0x01	; 1
     1a2:	67 e0       	ldi	r22, 0x07	; 7
     1a4:	82 e0       	ldi	r24, 0x02	; 2
     1a6:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
					DIO_voidSetPinDir(DIO_PORTC,DIO_PIN5,OUTPUT); // heater led indicator 
     1aa:	41 e0       	ldi	r20, 0x01	; 1
     1ac:	65 e0       	ldi	r22, 0x05	; 5
     1ae:	82 e0       	ldi	r24, 0x02	; 2
     1b0:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
					DIO_voidSetPinVal(DIO_PORTD,DIO_PIN3,HIGH);   // on-off green led
     1b4:	41 e0       	ldi	r20, 0x01	; 1
     1b6:	63 e0       	ldi	r22, 0x03	; 3
     1b8:	83 e0       	ldi	r24, 0x03	; 3
     1ba:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
					count ++;
     1be:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <count.2276>
     1c2:	8f 5f       	subi	r24, 0xFF	; 255
     1c4:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <count.2276>
     1c8:	30 c0       	rjmp	.+96     	; 0x22a <task4+0xc8>
					
				}
			else if ((DIO_u8ReadpinVal(DIO_PORTB,DIO_PIN0)==1) && count==1)
     1ca:	60 e0       	ldi	r22, 0x00	; 0
     1cc:	81 e0       	ldi	r24, 0x01	; 1
     1ce:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     1d2:	81 30       	cpi	r24, 0x01	; 1
     1d4:	51 f5       	brne	.+84     	; 0x22a <task4+0xc8>
     1d6:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <count.2276>
     1da:	81 30       	cpi	r24, 0x01	; 1
     1dc:	31 f5       	brne	.+76     	; 0x22a <task4+0xc8>
				{
					while(DIO_u8ReadpinVal(DIO_PORTB,DIO_PIN0)==1);
     1de:	60 e0       	ldi	r22, 0x00	; 0
     1e0:	81 e0       	ldi	r24, 0x01	; 1
     1e2:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     1e6:	81 30       	cpi	r24, 0x01	; 1
     1e8:	d1 f3       	breq	.-12     	; 0x1de <task4+0x7c>
					DIO_voidSetPinDir(DIO_PORTB,DIO_PIN1,INPUT); // SSD enable 1
     1ea:	40 e0       	ldi	r20, 0x00	; 0
     1ec:	61 e0       	ldi	r22, 0x01	; 1
     1ee:	81 e0       	ldi	r24, 0x01	; 1
     1f0:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
					DIO_voidSetPinDir(DIO_PORTB,DIO_PIN2,INPUT); // SSD enable 2
     1f4:	40 e0       	ldi	r20, 0x00	; 0
     1f6:	62 e0       	ldi	r22, 0x02	; 2
     1f8:	81 e0       	ldi	r24, 0x01	; 1
     1fa:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
					DIO_voidSetPinDir(DIO_PORTC,DIO_PIN2,INPUT); // heater relay
     1fe:	40 e0       	ldi	r20, 0x00	; 0
     200:	62 e0       	ldi	r22, 0x02	; 2
     202:	82 e0       	ldi	r24, 0x02	; 2
     204:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
					DIO_voidSetPinDir(DIO_PORTC,DIO_PIN7,INPUT); // cooling fan relay
     208:	40 e0       	ldi	r20, 0x00	; 0
     20a:	67 e0       	ldi	r22, 0x07	; 7
     20c:	82 e0       	ldi	r24, 0x02	; 2
     20e:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
					DIO_voidSetPinDir(DIO_PORTC,DIO_PIN5,INPUT); // heater led indicator 
     212:	40 e0       	ldi	r20, 0x00	; 0
     214:	65 e0       	ldi	r22, 0x05	; 5
     216:	82 e0       	ldi	r24, 0x02	; 2
     218:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
					DIO_voidSetPinVal(DIO_PORTD,DIO_PIN3,LOW);	 // on-off green led
     21c:	40 e0       	ldi	r20, 0x00	; 0
     21e:	63 e0       	ldi	r22, 0x03	; 3
     220:	83 e0       	ldi	r24, 0x03	; 3
     222:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
					count = 0;
     226:	10 92 86 00 	sts	0x0086, r1	; 0x800086 <count.2276>
				}
				xQueueSend(temp1,&count,100);
     22a:	20 e0       	ldi	r18, 0x00	; 0
     22c:	44 e6       	ldi	r20, 0x64	; 100
     22e:	50 e0       	ldi	r21, 0x00	; 0
     230:	66 e8       	ldi	r22, 0x86	; 134
     232:	70 e0       	ldi	r23, 0x00	; 0
     234:	80 91 22 05 	lds	r24, 0x0522	; 0x800522 <temp1>
     238:	90 91 23 05 	lds	r25, 0x0523	; 0x800523 <temp1+0x1>
     23c:	0e 94 80 07 	call	0xf00	; 0xf00 <xQueueGenericSend>
			vTaskDelay(20);
     240:	84 e1       	ldi	r24, 0x14	; 20
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	0e 94 05 0c 	call	0x180a	; 0x180a <vTaskDelay>
		}
     248:	8c cf       	rjmp	.-232    	; 0x162 <task4>

0000024a <task1>:
	static u8 ssd_blinking =0;
	
	
	while (1)
	{
		xQueueReceive(temp1,&on_off,100);
     24a:	20 e0       	ldi	r18, 0x00	; 0
     24c:	44 e6       	ldi	r20, 0x64	; 100
     24e:	50 e0       	ldi	r21, 0x00	; 0
     250:	69 e8       	ldi	r22, 0x89	; 137
     252:	70 e0       	ldi	r23, 0x00	; 0
     254:	80 91 22 05 	lds	r24, 0x0522	; 0x800522 <temp1>
     258:	90 91 23 05 	lds	r25, 0x0523	; 0x800523 <temp1+0x1>
     25c:	0e 94 12 08 	call	0x1024	; 0x1024 <xQueueGenericReceive>
		// check whether up or down button is pressed to enter temperature setting mode
		if ((DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN2)==1) || (DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN6)==1))
     260:	62 e0       	ldi	r22, 0x02	; 2
     262:	83 e0       	ldi	r24, 0x03	; 3
     264:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     268:	81 30       	cpi	r24, 0x01	; 1
     26a:	39 f0       	breq	.+14     	; 0x27a <task1+0x30>
     26c:	66 e0       	ldi	r22, 0x06	; 6
     26e:	83 e0       	ldi	r24, 0x03	; 3
     270:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     274:	81 30       	cpi	r24, 0x01	; 1
     276:	09 f0       	breq	.+2      	; 0x27a <task1+0x30>
     278:	d3 c0       	rjmp	.+422    	; 0x420 <__EEPROM_REGION_LENGTH__+0x20>
			{
				while((DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN2)==1) || (DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN6)==1));
     27a:	62 e0       	ldi	r22, 0x02	; 2
     27c:	83 e0       	ldi	r24, 0x03	; 3
     27e:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     282:	81 30       	cpi	r24, 0x01	; 1
     284:	d1 f3       	breq	.-12     	; 0x27a <task1+0x30>
     286:	66 e0       	ldi	r22, 0x06	; 6
     288:	83 e0       	ldi	r24, 0x03	; 3
     28a:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     28e:	81 30       	cpi	r24, 0x01	; 1
     290:	a1 f3       	breq	.-24     	; 0x27a <task1+0x30>
				
				xSemaphoreTake(SSD,10);	
     292:	20 e0       	ldi	r18, 0x00	; 0
     294:	4a e0       	ldi	r20, 0x0A	; 10
     296:	50 e0       	ldi	r21, 0x00	; 0
     298:	60 e0       	ldi	r22, 0x00	; 0
     29a:	70 e0       	ldi	r23, 0x00	; 0
     29c:	80 91 26 05 	lds	r24, 0x0526	; 0x800526 <SSD>
     2a0:	90 91 27 05 	lds	r25, 0x0527	; 0x800527 <SSD+0x1>
     2a4:	0e 94 12 08 	call	0x1024	; 0x1024 <xQueueGenericReceive>
				// in temperature setting mode if on/off button is pressed it shuts down the system
				if (on_off==1)
     2a8:	80 91 89 00 	lds	r24, 0x0089	; 0x800089 <on_off.2240>
     2ac:	81 30       	cpi	r24, 0x01	; 1
     2ae:	09 f0       	breq	.+2      	; 0x2b2 <task1+0x68>
     2b0:	ac c0       	rjmp	.+344    	; 0x40a <__EEPROM_REGION_LENGTH__+0xa>
				{
					// get the Preset temperature from the EEPROM
					current_preset_temp = EEPROM_voidRecieveDataFromEEPROM(0);
     2b2:	80 e0       	ldi	r24, 0x00	; 0
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	0e 94 14 0e 	call	0x1c28	; 0x1c28 <EEPROM_voidRecieveDataFromEEPROM>
     2ba:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <current_preset_temp.2239>
					
					// temperature setting mode ends after 5 seconds if no buttons are pressed
					for (u8 z=0 ; z<249 ; z++)
     2be:	10 e0       	ldi	r17, 0x00	; 0
     2c0:	a1 c0       	rjmp	.+322    	; 0x404 <__EEPROM_REGION_LENGTH__+0x4>
					{
						// to break the loop if on/off button is pressed
						if (DIO_u8ReadpinVal(DIO_PORTB,DIO_PIN0)==1)
     2c2:	60 e0       	ldi	r22, 0x00	; 0
     2c4:	81 e0       	ldi	r24, 0x01	; 1
     2c6:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     2ca:	81 30       	cpi	r24, 0x01	; 1
     2cc:	09 f4       	brne	.+2      	; 0x2d0 <task1+0x86>
     2ce:	9d c0       	rjmp	.+314    	; 0x40a <__EEPROM_REGION_LENGTH__+0xa>
						{break;}
						// counter for SSD blinking
						ssd_blinking ++;
     2d0:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <ssd_blinking.2241>
     2d4:	8f 5f       	subi	r24, 0xFF	; 255
     2d6:	80 93 87 00 	sts	0x0087, r24	; 0x800087 <ssd_blinking.2241>
						if (ssd_blinking==23)
     2da:	87 31       	cpi	r24, 0x17	; 23
     2dc:	59 f4       	brne	.+22     	; 0x2f4 <task1+0xaa>
						{
							DIO_voidSetPinDir(DIO_PORTB,DIO_PIN1,INPUT); // SSD enable 1
     2de:	40 e0       	ldi	r20, 0x00	; 0
     2e0:	61 e0       	ldi	r22, 0x01	; 1
     2e2:	81 e0       	ldi	r24, 0x01	; 1
     2e4:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
							DIO_voidSetPinDir(DIO_PORTB,DIO_PIN2,INPUT); // SSD enable 2
     2e8:	40 e0       	ldi	r20, 0x00	; 0
     2ea:	62 e0       	ldi	r22, 0x02	; 2
     2ec:	81 e0       	ldi	r24, 0x01	; 1
     2ee:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
     2f2:	0e c0       	rjmp	.+28     	; 0x310 <task1+0xc6>
						}
						else if (ssd_blinking==27)
     2f4:	8b 31       	cpi	r24, 0x1B	; 27
     2f6:	61 f4       	brne	.+24     	; 0x310 <task1+0xc6>
						{
							DIO_voidSetPinDir(DIO_PORTB,DIO_PIN1,OUTPUT); // SSD enable 1
     2f8:	41 e0       	ldi	r20, 0x01	; 1
     2fa:	61 e0       	ldi	r22, 0x01	; 1
     2fc:	81 e0       	ldi	r24, 0x01	; 1
     2fe:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
							DIO_voidSetPinDir(DIO_PORTB,DIO_PIN2,OUTPUT); // SSD enable 2
     302:	41 e0       	ldi	r20, 0x01	; 1
     304:	62 e0       	ldi	r22, 0x02	; 2
     306:	81 e0       	ldi	r24, 0x01	; 1
     308:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
							ssd_blinking=0;
     30c:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <ssd_blinking.2241>
						}
						/* if up button is pressed increase the preset temperature by 5 with  
						   maximum value being 75 degrees ,and store new value in EEPROM */
						if ((DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN2)==1) && (current_preset_temp<=70))
     310:	62 e0       	ldi	r22, 0x02	; 2
     312:	83 e0       	ldi	r24, 0x03	; 3
     314:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     318:	81 30       	cpi	r24, 0x01	; 1
     31a:	b1 f4       	brne	.+44     	; 0x348 <task1+0xfe>
     31c:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <current_preset_temp.2239>
     320:	87 34       	cpi	r24, 0x47	; 71
     322:	90 f4       	brcc	.+36     	; 0x348 <task1+0xfe>
						{
							while(DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN2)==1);
     324:	62 e0       	ldi	r22, 0x02	; 2
     326:	83 e0       	ldi	r24, 0x03	; 3
     328:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     32c:	81 30       	cpi	r24, 0x01	; 1
     32e:	d1 f3       	breq	.-12     	; 0x324 <task1+0xda>
							current_preset_temp = current_preset_temp + 5;
     330:	60 91 88 00 	lds	r22, 0x0088	; 0x800088 <current_preset_temp.2239>
     334:	6b 5f       	subi	r22, 0xFB	; 251
     336:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <current_preset_temp.2239>
							EEPROM_voidSendDataToEEPROM(0,current_preset_temp);
     33a:	80 e0       	ldi	r24, 0x00	; 0
     33c:	90 e0       	ldi	r25, 0x00	; 0
     33e:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <EEPROM_voidSendDataToEEPROM>
							z=0;
							ssd_blinking=0;
     342:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <ssd_blinking.2241>
						if ((DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN2)==1) && (current_preset_temp<=70))
						{
							while(DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN2)==1);
							current_preset_temp = current_preset_temp + 5;
							EEPROM_voidSendDataToEEPROM(0,current_preset_temp);
							z=0;
     346:	10 e0       	ldi	r17, 0x00	; 0
							ssd_blinking=0;
						}
						/* if down button is pressed decrease the preset temperature by 5 with  
						   minimum value being 35 degrees ,and store new value in EEPROM */
						if ((DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN6)==1) && (current_preset_temp>=40))
     348:	66 e0       	ldi	r22, 0x06	; 6
     34a:	83 e0       	ldi	r24, 0x03	; 3
     34c:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     350:	81 30       	cpi	r24, 0x01	; 1
     352:	b1 f4       	brne	.+44     	; 0x380 <task1+0x136>
     354:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <current_preset_temp.2239>
     358:	88 32       	cpi	r24, 0x28	; 40
     35a:	90 f0       	brcs	.+36     	; 0x380 <task1+0x136>
						{
							while(DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN6)==1);
     35c:	66 e0       	ldi	r22, 0x06	; 6
     35e:	83 e0       	ldi	r24, 0x03	; 3
     360:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <DIO_u8ReadpinVal>
     364:	81 30       	cpi	r24, 0x01	; 1
     366:	d1 f3       	breq	.-12     	; 0x35c <task1+0x112>
							current_preset_temp = current_preset_temp - 5;
     368:	60 91 88 00 	lds	r22, 0x0088	; 0x800088 <current_preset_temp.2239>
     36c:	65 50       	subi	r22, 0x05	; 5
     36e:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <current_preset_temp.2239>
							EEPROM_voidSendDataToEEPROM(0,current_preset_temp);
     372:	80 e0       	ldi	r24, 0x00	; 0
     374:	90 e0       	ldi	r25, 0x00	; 0
     376:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <EEPROM_voidSendDataToEEPROM>
							z=0;
							ssd_blinking=0;
     37a:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <ssd_blinking.2241>
						if ((DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN6)==1) && (current_preset_temp>=40))
						{
							while(DIO_u8ReadpinVal(DIO_PORTD,DIO_PIN6)==1);
							current_preset_temp = current_preset_temp - 5;
							EEPROM_voidSendDataToEEPROM(0,current_preset_temp);
							z=0;
     37e:	10 e0       	ldi	r17, 0x00	; 0
							ssd_blinking=0;
						}
						
						// display the set temperature while in temperature setting mode
						SSD_disp_0 =current_preset_temp%10;
     380:	20 91 88 00 	lds	r18, 0x0088	; 0x800088 <current_preset_temp.2239>
     384:	8d ec       	ldi	r24, 0xCD	; 205
     386:	28 9f       	mul	r18, r24
     388:	81 2d       	mov	r24, r1
     38a:	11 24       	eor	r1, r1
     38c:	c8 2f       	mov	r28, r24
     38e:	c6 95       	lsr	r28
     390:	c6 95       	lsr	r28
     392:	c6 95       	lsr	r28
     394:	cc 0f       	add	r28, r28
     396:	9c 2f       	mov	r25, r28
     398:	99 0f       	add	r25, r25
     39a:	99 0f       	add	r25, r25
     39c:	c9 0f       	add	r28, r25
     39e:	2c 1b       	sub	r18, r28
     3a0:	c2 2f       	mov	r28, r18
						SSD_disp_10=current_preset_temp/10;
     3a2:	d8 2f       	mov	r29, r24
     3a4:	d6 95       	lsr	r29
     3a6:	d6 95       	lsr	r29
     3a8:	d6 95       	lsr	r29
						
						DIO_voidSetPinVal(DIO_PORTB,DIO_PIN2,HIGH);
     3aa:	41 e0       	ldi	r20, 0x01	; 1
     3ac:	62 e0       	ldi	r22, 0x02	; 2
     3ae:	81 e0       	ldi	r24, 0x01	; 1
     3b0:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
						DIO_voidSetPinVal(DIO_PORTB,DIO_PIN1,LOW);
     3b4:	40 e0       	ldi	r20, 0x00	; 0
     3b6:	61 e0       	ldi	r22, 0x01	; 1
     3b8:	81 e0       	ldi	r24, 0x01	; 1
     3ba:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
						SSD_voidDisplayNum(SSD_disp_10) ;
     3be:	8d 2f       	mov	r24, r29
     3c0:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <SSD_voidDisplayNum>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3c4:	2f ef       	ldi	r18, 0xFF	; 255
     3c6:	89 ef       	ldi	r24, 0xF9	; 249
     3c8:	90 e0       	ldi	r25, 0x00	; 0
     3ca:	21 50       	subi	r18, 0x01	; 1
     3cc:	80 40       	sbci	r24, 0x00	; 0
     3ce:	90 40       	sbci	r25, 0x00	; 0
     3d0:	e1 f7       	brne	.-8      	; 0x3ca <task1+0x180>
     3d2:	00 c0       	rjmp	.+0      	; 0x3d4 <task1+0x18a>
     3d4:	00 00       	nop
						_delay_ms(20);
						DIO_voidSetPinVal(DIO_PORTB,DIO_PIN1,HIGH);
     3d6:	41 e0       	ldi	r20, 0x01	; 1
     3d8:	61 e0       	ldi	r22, 0x01	; 1
     3da:	81 e0       	ldi	r24, 0x01	; 1
     3dc:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
						DIO_voidSetPinVal(DIO_PORTB,DIO_PIN2,LOW);
     3e0:	40 e0       	ldi	r20, 0x00	; 0
     3e2:	62 e0       	ldi	r22, 0x02	; 2
     3e4:	81 e0       	ldi	r24, 0x01	; 1
     3e6:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
						SSD_voidDisplayNum(SSD_disp_0) ;
     3ea:	8c 2f       	mov	r24, r28
     3ec:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <SSD_voidDisplayNum>
     3f0:	2f ef       	ldi	r18, 0xFF	; 255
     3f2:	89 ef       	ldi	r24, 0xF9	; 249
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	21 50       	subi	r18, 0x01	; 1
     3f8:	80 40       	sbci	r24, 0x00	; 0
     3fa:	90 40       	sbci	r25, 0x00	; 0
     3fc:	e1 f7       	brne	.-8      	; 0x3f6 <task1+0x1ac>
     3fe:	00 c0       	rjmp	.+0      	; 0x400 <__EEPROM_REGION_LENGTH__>
     400:	00 00       	nop
				{
					// get the Preset temperature from the EEPROM
					current_preset_temp = EEPROM_voidRecieveDataFromEEPROM(0);
					
					// temperature setting mode ends after 5 seconds if no buttons are pressed
					for (u8 z=0 ; z<249 ; z++)
     402:	1f 5f       	subi	r17, 0xFF	; 255
     404:	19 3f       	cpi	r17, 0xF9	; 249
     406:	08 f4       	brcc	.+2      	; 0x40a <__EEPROM_REGION_LENGTH__+0xa>
     408:	5c cf       	rjmp	.-328    	; 0x2c2 <task1+0x78>
						DIO_voidSetPinVal(DIO_PORTB,DIO_PIN2,LOW);
						SSD_voidDisplayNum(SSD_disp_0) ;
						_delay_ms(20);
					}
				}	
				xSemaphoreGive(SSD);	
     40a:	20 e0       	ldi	r18, 0x00	; 0
     40c:	40 e0       	ldi	r20, 0x00	; 0
     40e:	50 e0       	ldi	r21, 0x00	; 0
     410:	60 e0       	ldi	r22, 0x00	; 0
     412:	70 e0       	ldi	r23, 0x00	; 0
     414:	80 91 26 05 	lds	r24, 0x0526	; 0x800526 <SSD>
     418:	90 91 27 05 	lds	r25, 0x0527	; 0x800527 <SSD+0x1>
     41c:	0e 94 80 07 	call	0xf00	; 0xf00 <xQueueGenericSend>
		}
		vTaskDelay(20);
     420:	84 e1       	ldi	r24, 0x14	; 20
     422:	90 e0       	ldi	r25, 0x00	; 0
     424:	0e 94 05 0c 	call	0x180a	; 0x180a <vTaskDelay>
	}
     428:	10 cf       	rjmp	.-480    	; 0x24a <task1>

0000042a <task2>:
	u8 SSD_disp_10 =0;
	
	while (1)
		{

			xSemaphoreTake(SSD,10);
     42a:	20 e0       	ldi	r18, 0x00	; 0
     42c:	4a e0       	ldi	r20, 0x0A	; 10
     42e:	50 e0       	ldi	r21, 0x00	; 0
     430:	60 e0       	ldi	r22, 0x00	; 0
     432:	70 e0       	ldi	r23, 0x00	; 0
     434:	80 91 26 05 	lds	r24, 0x0526	; 0x800526 <SSD>
     438:	90 91 27 05 	lds	r25, 0x0527	; 0x800527 <SSD+0x1>
     43c:	0e 94 12 08 	call	0x1024	; 0x1024 <xQueueGenericReceive>
			SSD_disp_0 =Average_Temp%10;
     440:	90 91 21 05 	lds	r25, 0x0521	; 0x800521 <Average_Temp>
     444:	dd ec       	ldi	r29, 0xCD	; 205
     446:	9d 9f       	mul	r25, r29
     448:	d1 2d       	mov	r29, r1
     44a:	11 24       	eor	r1, r1
     44c:	1d 2f       	mov	r17, r29
     44e:	16 95       	lsr	r17
     450:	16 95       	lsr	r17
     452:	16 95       	lsr	r17
     454:	11 0f       	add	r17, r17
     456:	81 2f       	mov	r24, r17
     458:	88 0f       	add	r24, r24
     45a:	88 0f       	add	r24, r24
     45c:	18 0f       	add	r17, r24
     45e:	91 1b       	sub	r25, r17
     460:	19 2f       	mov	r17, r25
			SSD_disp_10=Average_Temp/10;
     462:	d6 95       	lsr	r29
     464:	d6 95       	lsr	r29
     466:	d6 95       	lsr	r29
			// display the temperature from lm35 sensor
			for (u8 z=0 ; z<2 ; z++)
     468:	c0 e0       	ldi	r28, 0x00	; 0
     46a:	2d c0       	rjmp	.+90     	; 0x4c6 <task2+0x9c>
				{
					DIO_voidSetPinVal(DIO_PORTB,DIO_PIN2,HIGH);
     46c:	41 e0       	ldi	r20, 0x01	; 1
     46e:	62 e0       	ldi	r22, 0x02	; 2
     470:	81 e0       	ldi	r24, 0x01	; 1
     472:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
					DIO_voidSetPinVal(DIO_PORTB,DIO_PIN1,LOW);
     476:	40 e0       	ldi	r20, 0x00	; 0
     478:	61 e0       	ldi	r22, 0x01	; 1
     47a:	81 e0       	ldi	r24, 0x01	; 1
     47c:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
					SSD_voidDisplayNum(SSD_disp_10) ;
     480:	8d 2f       	mov	r24, r29
     482:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <SSD_voidDisplayNum>
     486:	2f ef       	ldi	r18, 0xFF	; 255
     488:	89 ef       	ldi	r24, 0xF9	; 249
     48a:	90 e0       	ldi	r25, 0x00	; 0
     48c:	21 50       	subi	r18, 0x01	; 1
     48e:	80 40       	sbci	r24, 0x00	; 0
     490:	90 40       	sbci	r25, 0x00	; 0
     492:	e1 f7       	brne	.-8      	; 0x48c <task2+0x62>
     494:	00 c0       	rjmp	.+0      	; 0x496 <task2+0x6c>
     496:	00 00       	nop
					_delay_ms(20);
					DIO_voidSetPinVal(DIO_PORTB,DIO_PIN1,HIGH);
     498:	41 e0       	ldi	r20, 0x01	; 1
     49a:	61 e0       	ldi	r22, 0x01	; 1
     49c:	81 e0       	ldi	r24, 0x01	; 1
     49e:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
					DIO_voidSetPinVal(DIO_PORTB,DIO_PIN2,LOW);
     4a2:	40 e0       	ldi	r20, 0x00	; 0
     4a4:	62 e0       	ldi	r22, 0x02	; 2
     4a6:	81 e0       	ldi	r24, 0x01	; 1
     4a8:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DIO_voidSetPinVal>
					SSD_voidDisplayNum(SSD_disp_0) ;
     4ac:	81 2f       	mov	r24, r17
     4ae:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <SSD_voidDisplayNum>
     4b2:	2f ef       	ldi	r18, 0xFF	; 255
     4b4:	89 ef       	ldi	r24, 0xF9	; 249
     4b6:	90 e0       	ldi	r25, 0x00	; 0
     4b8:	21 50       	subi	r18, 0x01	; 1
     4ba:	80 40       	sbci	r24, 0x00	; 0
     4bc:	90 40       	sbci	r25, 0x00	; 0
     4be:	e1 f7       	brne	.-8      	; 0x4b8 <task2+0x8e>
     4c0:	00 c0       	rjmp	.+0      	; 0x4c2 <task2+0x98>
     4c2:	00 00       	nop

			xSemaphoreTake(SSD,10);
			SSD_disp_0 =Average_Temp%10;
			SSD_disp_10=Average_Temp/10;
			// display the temperature from lm35 sensor
			for (u8 z=0 ; z<2 ; z++)
     4c4:	cf 5f       	subi	r28, 0xFF	; 255
     4c6:	c2 30       	cpi	r28, 0x02	; 2
     4c8:	88 f2       	brcs	.-94     	; 0x46c <task2+0x42>
					DIO_voidSetPinVal(DIO_PORTB,DIO_PIN1,HIGH);
					DIO_voidSetPinVal(DIO_PORTB,DIO_PIN2,LOW);
					SSD_voidDisplayNum(SSD_disp_0) ;
					_delay_ms(20);
				}
			xSemaphoreGive(SSD);
     4ca:	20 e0       	ldi	r18, 0x00	; 0
     4cc:	40 e0       	ldi	r20, 0x00	; 0
     4ce:	50 e0       	ldi	r21, 0x00	; 0
     4d0:	60 e0       	ldi	r22, 0x00	; 0
     4d2:	70 e0       	ldi	r23, 0x00	; 0
     4d4:	80 91 26 05 	lds	r24, 0x0526	; 0x800526 <SSD>
     4d8:	90 91 27 05 	lds	r25, 0x0527	; 0x800527 <SSD+0x1>
     4dc:	0e 94 80 07 	call	0xf00	; 0xf00 <xQueueGenericSend>
			vTaskDelay(20);
     4e0:	84 e1       	ldi	r24, 0x14	; 20
     4e2:	90 e0       	ldi	r25, 0x00	; 0
     4e4:	0e 94 05 0c 	call	0x180a	; 0x180a <vTaskDelay>
		}
     4e8:	a0 cf       	rjmp	.-192    	; 0x42a <task2>

000004ea <Time>:
// define a function to pass to the set call back function
// sense temperature every 100 ms and calculates the average temperature of the last 10 readings
// responsible for the led blinking every 1 sec
// counter values were changed for the simulation to work properly 
void Time (void)
{
     4ea:	0f 93       	push	r16
     4ec:	1f 93       	push	r17
     4ee:	cf 93       	push	r28
	static u16 counter2=0;
	f32 total =0;
	static f32 temperature=0;
	static u16 i=0;
	
	counter1 ++;
     4f0:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <counter1.2292>
     4f4:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <counter1.2292+0x1>
     4f8:	01 96       	adiw	r24, 0x01	; 1
     4fa:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <counter1.2292+0x1>
     4fe:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <counter1.2292>
	counter2 ++;
     502:	20 91 82 00 	lds	r18, 0x0082	; 0x800082 <counter2.2293>
     506:	30 91 83 00 	lds	r19, 0x0083	; 0x800083 <counter2.2293+0x1>
     50a:	2f 5f       	subi	r18, 0xFF	; 255
     50c:	3f 4f       	sbci	r19, 0xFF	; 255
     50e:	30 93 83 00 	sts	0x0083, r19	; 0x800083 <counter2.2293+0x1>
     512:	20 93 82 00 	sts	0x0082, r18	; 0x800082 <counter2.2293>
		
	if (counter1==10)
     516:	0a 97       	sbiw	r24, 0x0a	; 10
     518:	09 f0       	breq	.+2      	; 0x51c <Time+0x32>
     51a:	54 c0       	rjmp	.+168    	; 0x5c4 <Time+0xda>
	{
		temperature=(f32)ADC_u16ReadChannel(ADC_0);
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <ADC_u16ReadChannel>
     522:	bc 01       	movw	r22, r24
     524:	80 e0       	ldi	r24, 0x00	; 0
     526:	90 e0       	ldi	r25, 0x00	; 0
     528:	0e 94 9d 12 	call	0x253a	; 0x253a <__floatunsisf>
		temperature=temperature*500/1023;
     52c:	20 e0       	ldi	r18, 0x00	; 0
     52e:	30 e0       	ldi	r19, 0x00	; 0
     530:	4a ef       	ldi	r20, 0xFA	; 250
     532:	53 e4       	ldi	r21, 0x43	; 67
     534:	0e 94 2b 13 	call	0x2656	; 0x2656 <__mulsf3>
     538:	20 e0       	ldi	r18, 0x00	; 0
     53a:	30 ec       	ldi	r19, 0xC0	; 192
     53c:	4f e7       	ldi	r20, 0x7F	; 127
     53e:	54 e4       	ldi	r21, 0x44	; 68
     540:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <__divsf3>
		Temperature_Reading[i] = temperature;
     544:	00 91 80 00 	lds	r16, 0x0080	; 0x800080 <__data_end>
     548:	10 91 81 00 	lds	r17, 0x0081	; 0x800081 <__data_end+0x1>
     54c:	f8 01       	movw	r30, r16
     54e:	ee 0f       	add	r30, r30
     550:	ff 1f       	adc	r31, r31
     552:	ee 0f       	add	r30, r30
     554:	ff 1f       	adc	r31, r31
     556:	e7 50       	subi	r30, 0x07	; 7
     558:	fb 4f       	sbci	r31, 0xFB	; 251
     55a:	60 83       	st	Z, r22
     55c:	71 83       	std	Z+1, r23	; 0x01
     55e:	82 83       	std	Z+2, r24	; 0x02
     560:	93 83       	std	Z+3, r25	; 0x03
		for (u8 x=0 ; x<10 ; x++)
     562:	c0 e0       	ldi	r28, 0x00	; 0
// counter values were changed for the simulation to work properly 
void Time (void)
{
	static u16 counter1=0;
	static u16 counter2=0;
	f32 total =0;
     564:	60 e0       	ldi	r22, 0x00	; 0
     566:	70 e0       	ldi	r23, 0x00	; 0
     568:	cb 01       	movw	r24, r22
	if (counter1==10)
	{
		temperature=(f32)ADC_u16ReadChannel(ADC_0);
		temperature=temperature*500/1023;
		Temperature_Reading[i] = temperature;
		for (u8 x=0 ; x<10 ; x++)
     56a:	0f c0       	rjmp	.+30     	; 0x58a <Time+0xa0>
		{
			total=total+Temperature_Reading[x];
     56c:	ec 2f       	mov	r30, r28
     56e:	f0 e0       	ldi	r31, 0x00	; 0
     570:	ee 0f       	add	r30, r30
     572:	ff 1f       	adc	r31, r31
     574:	ee 0f       	add	r30, r30
     576:	ff 1f       	adc	r31, r31
     578:	e7 50       	subi	r30, 0x07	; 7
     57a:	fb 4f       	sbci	r31, 0xFB	; 251
     57c:	20 81       	ld	r18, Z
     57e:	31 81       	ldd	r19, Z+1	; 0x01
     580:	42 81       	ldd	r20, Z+2	; 0x02
     582:	53 81       	ldd	r21, Z+3	; 0x03
     584:	0e 94 90 11 	call	0x2320	; 0x2320 <__addsf3>
	if (counter1==10)
	{
		temperature=(f32)ADC_u16ReadChannel(ADC_0);
		temperature=temperature*500/1023;
		Temperature_Reading[i] = temperature;
		for (u8 x=0 ; x<10 ; x++)
     588:	cf 5f       	subi	r28, 0xFF	; 255
     58a:	ca 30       	cpi	r28, 0x0A	; 10
     58c:	78 f3       	brcs	.-34     	; 0x56c <Time+0x82>
		{
			total=total+Temperature_Reading[x];
		}
		Average_Temp=(u32)total/10;
     58e:	0e 94 6e 12 	call	0x24dc	; 0x24dc <__fixunssfsi>
     592:	2a e0       	ldi	r18, 0x0A	; 10
     594:	30 e0       	ldi	r19, 0x00	; 0
     596:	40 e0       	ldi	r20, 0x00	; 0
     598:	50 e0       	ldi	r21, 0x00	; 0
     59a:	0e 94 98 13 	call	0x2730	; 0x2730 <__udivmodsi4>
     59e:	20 93 21 05 	sts	0x0521, r18	; 0x800521 <Average_Temp>
		i++;
     5a2:	0f 5f       	subi	r16, 0xFF	; 255
     5a4:	1f 4f       	sbci	r17, 0xFF	; 255
     5a6:	10 93 81 00 	sts	0x0081, r17	; 0x800081 <__data_end+0x1>
     5aa:	00 93 80 00 	sts	0x0080, r16	; 0x800080 <__data_end>
		if (i==10) {i=0;}
     5ae:	0a 30       	cpi	r16, 0x0A	; 10
     5b0:	11 05       	cpc	r17, r1
     5b2:	21 f4       	brne	.+8      	; 0x5bc <Time+0xd2>
     5b4:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__data_end+0x1>
     5b8:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__data_end>
		counter1 = 0 ;
     5bc:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <counter1.2292+0x1>
     5c0:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <counter1.2292>
	}
	if (counter2==100)
     5c4:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <counter2.2293>
     5c8:	90 91 83 00 	lds	r25, 0x0083	; 0x800083 <counter2.2293+0x1>
     5cc:	84 36       	cpi	r24, 0x64	; 100
     5ce:	91 05       	cpc	r25, r1
     5d0:	71 f4       	brne	.+28     	; 0x5ee <Time+0x104>
	{
		if (Time_y==1)	{Time_y=0;}
     5d2:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <Time_y>
     5d6:	81 30       	cpi	r24, 0x01	; 1
     5d8:	19 f4       	brne	.+6      	; 0x5e0 <Time+0xf6>
     5da:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <Time_y>
     5de:	03 c0       	rjmp	.+6      	; 0x5e6 <Time+0xfc>
		else			{Time_y=1;}
     5e0:	81 e0       	ldi	r24, 0x01	; 1
     5e2:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <Time_y>
		counter2= 0 ;
     5e6:	10 92 83 00 	sts	0x0083, r1	; 0x800083 <counter2.2293+0x1>
     5ea:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <counter2.2293>
	}
}
     5ee:	cf 91       	pop	r28
     5f0:	1f 91       	pop	r17
     5f2:	0f 91       	pop	r16
     5f4:	08 95       	ret

000005f6 <main>:
}



int main(void)
{
     5f6:	ef 92       	push	r14
     5f8:	ff 92       	push	r15
     5fa:	0f 93       	push	r16
	
	// TWI initialization
	TWI_voidMasterInit(0);
     5fc:	80 e0       	ldi	r24, 0x00	; 0
     5fe:	0e 94 07 11 	call	0x220e	; 0x220e <TWI_voidMasterInit>
	
	// enable global interrupt
	GI_voidEnable();
     602:	0e 94 16 10 	call	0x202c	; 0x202c <GI_voidEnable>
	
	// initializing timer 0 CTC mode and set call back Function
	TIM0_voidInitCTC_OV(1);
     606:	81 e0       	ldi	r24, 0x01	; 1
     608:	0e 94 1a 10 	call	0x2034	; 0x2034 <TIM0_voidInitCTC_OV>
	TIM0_voidSetCallBack(Time,1);
     60c:	61 e0       	ldi	r22, 0x01	; 1
     60e:	85 e7       	ldi	r24, 0x75	; 117
     610:	92 e0       	ldi	r25, 0x02	; 2
     612:	0e 94 3a 10 	call	0x2074	; 0x2074 <TIM0_voidSetCallBack>
	 
	// setting initial value of temp in EEPROM
	EEPROM_voidSendDataToEEPROM(0,60);
     616:	6c e3       	ldi	r22, 0x3C	; 60
     618:	80 e0       	ldi	r24, 0x00	; 0
     61a:	90 e0       	ldi	r25, 0x00	; 0
     61c:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <EEPROM_voidSendDataToEEPROM>

	// input buttons Dir
	DIO_voidSetPinDir(DIO_PORTB,DIO_PIN0,INPUT);  // on_off
     620:	40 e0       	ldi	r20, 0x00	; 0
     622:	60 e0       	ldi	r22, 0x00	; 0
     624:	81 e0       	ldi	r24, 0x01	; 1
     626:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
	DIO_voidSetPinDir(DIO_PORTD,DIO_PIN2,INPUT);  // up
     62a:	40 e0       	ldi	r20, 0x00	; 0
     62c:	62 e0       	ldi	r22, 0x02	; 2
     62e:	83 e0       	ldi	r24, 0x03	; 3
     630:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
	DIO_voidSetPinDir(DIO_PORTD,DIO_PIN6,INPUT);  // down
     634:	40 e0       	ldi	r20, 0x00	; 0
     636:	66 e0       	ldi	r22, 0x06	; 6
     638:	83 e0       	ldi	r24, 0x03	; 3
     63a:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
	
	// on/off Led indicators Dir
	DIO_voidSetPinDir(DIO_PORTD,DIO_PIN3,OUTPUT);   // on-off green led	
     63e:	41 e0       	ldi	r20, 0x01	; 1
     640:	63 e0       	ldi	r22, 0x03	; 3
     642:	83 e0       	ldi	r24, 0x03	; 3
     644:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
	
	// DC motor Dir
	DIO_voidSetPinDir(DIO_PORTD , DIO_PIN4 , INPUT);
     648:	40 e0       	ldi	r20, 0x00	; 0
     64a:	64 e0       	ldi	r22, 0x04	; 4
     64c:	83 e0       	ldi	r24, 0x03	; 3
     64e:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
	DIO_voidSetPinDir(DIO_PORTD , DIO_PIN7 , OUTPUT);
     652:	41 e0       	ldi	r20, 0x01	; 1
     654:	67 e0       	ldi	r22, 0x07	; 7
     656:	83 e0       	ldi	r24, 0x03	; 3
     658:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
	DIO_voidSetPinDir(DIO_PORTC , DIO_PIN3 , OUTPUT);
     65c:	41 e0       	ldi	r20, 0x01	; 1
     65e:	63 e0       	ldi	r22, 0x03	; 3
     660:	82 e0       	ldi	r24, 0x02	; 2
     662:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
	DIO_voidSetPinDir(DIO_PORTC , DIO_PIN4 , OUTPUT);
     666:	41 e0       	ldi	r20, 0x01	; 1
     668:	64 e0       	ldi	r22, 0x04	; 4
     66a:	82 e0       	ldi	r24, 0x02	; 2
     66c:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <DIO_voidSetPinDir>
	
	// setting timer 2 for motor speed control
	TIM2_voidFastPWM(99);
     670:	83 e6       	ldi	r24, 0x63	; 99
     672:	0e 94 97 10 	call	0x212e	; 0x212e <TIM2_voidFastPWM>
	
	// ADC initialization for temperature sensor
	ADC_voidInit();
     676:	0e 94 4c 0e 	call	0x1c98	; 0x1c98 <ADC_voidInit>

	// Creating Project tasks
	xTaskCreate(&task1,"task1",80,NULL,2,NULL); // temperature setting mode task
     67a:	e1 2c       	mov	r14, r1
     67c:	f1 2c       	mov	r15, r1
     67e:	02 e0       	ldi	r16, 0x02	; 2
     680:	20 e0       	ldi	r18, 0x00	; 0
     682:	30 e0       	ldi	r19, 0x00	; 0
     684:	40 e5       	ldi	r20, 0x50	; 80
     686:	50 e0       	ldi	r21, 0x00	; 0
     688:	62 e6       	ldi	r22, 0x62	; 98
     68a:	70 e0       	ldi	r23, 0x00	; 0
     68c:	85 e2       	ldi	r24, 0x25	; 37
     68e:	91 e0       	ldi	r25, 0x01	; 1
     690:	0e 94 55 0a 	call	0x14aa	; 0x14aa <xTaskCreate>
	xTaskCreate(&task2,"task2",80,NULL,3,NULL); // lm35 sensor temperature display task
     694:	03 e0       	ldi	r16, 0x03	; 3
     696:	20 e0       	ldi	r18, 0x00	; 0
     698:	30 e0       	ldi	r19, 0x00	; 0
     69a:	40 e5       	ldi	r20, 0x50	; 80
     69c:	50 e0       	ldi	r21, 0x00	; 0
     69e:	68 e6       	ldi	r22, 0x68	; 104
     6a0:	70 e0       	ldi	r23, 0x00	; 0
     6a2:	85 e1       	ldi	r24, 0x15	; 21
     6a4:	92 e0       	ldi	r25, 0x02	; 2
     6a6:	0e 94 55 0a 	call	0x14aa	; 0x14aa <xTaskCreate>
	xTaskCreate(&task3,"task3",80,NULL,4,NULL); // decision based on temperature avg. and preset temperature task
     6aa:	04 e0       	ldi	r16, 0x04	; 4
     6ac:	20 e0       	ldi	r18, 0x00	; 0
     6ae:	30 e0       	ldi	r19, 0x00	; 0
     6b0:	40 e5       	ldi	r20, 0x50	; 80
     6b2:	50 e0       	ldi	r21, 0x00	; 0
     6b4:	6e e6       	ldi	r22, 0x6E	; 110
     6b6:	70 e0       	ldi	r23, 0x00	; 0
     6b8:	89 e4       	ldi	r24, 0x49	; 73
     6ba:	90 e0       	ldi	r25, 0x00	; 0
     6bc:	0e 94 55 0a 	call	0x14aa	; 0x14aa <xTaskCreate>
	xTaskCreate(&task4,"task4",80,NULL,1,NULL); // on/off button task
     6c0:	01 e0       	ldi	r16, 0x01	; 1
     6c2:	20 e0       	ldi	r18, 0x00	; 0
     6c4:	30 e0       	ldi	r19, 0x00	; 0
     6c6:	40 e5       	ldi	r20, 0x50	; 80
     6c8:	50 e0       	ldi	r21, 0x00	; 0
     6ca:	64 e7       	ldi	r22, 0x74	; 116
     6cc:	70 e0       	ldi	r23, 0x00	; 0
     6ce:	81 eb       	ldi	r24, 0xB1	; 177
     6d0:	90 e0       	ldi	r25, 0x00	; 0
     6d2:	0e 94 55 0a 	call	0x14aa	; 0x14aa <xTaskCreate>
	
	// Creating seven segments displays semaphore
	SSD = xSemaphoreCreateBinary();
     6d6:	43 e0       	ldi	r20, 0x03	; 3
     6d8:	60 e0       	ldi	r22, 0x00	; 0
     6da:	81 e0       	ldi	r24, 0x01	; 1
     6dc:	0e 94 56 07 	call	0xeac	; 0xeac <xQueueGenericCreate>
     6e0:	90 93 27 05 	sts	0x0527, r25	; 0x800527 <SSD+0x1>
     6e4:	80 93 26 05 	sts	0x0526, r24	; 0x800526 <SSD>
	
	// Creating temp handles for tasks
	temp1 = xQueueCreate(1,sizeof(u8));
     6e8:	40 e0       	ldi	r20, 0x00	; 0
     6ea:	61 e0       	ldi	r22, 0x01	; 1
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	0e 94 56 07 	call	0xeac	; 0xeac <xQueueGenericCreate>
     6f2:	90 93 23 05 	sts	0x0523, r25	; 0x800523 <temp1+0x1>
     6f6:	80 93 22 05 	sts	0x0522, r24	; 0x800522 <temp1>

	//Starting tasks scheduler
	vTaskStartScheduler();
     6fa:	0e 94 a9 0a 	call	0x1552	; 0x1552 <vTaskStartScheduler>
	
}
     6fe:	80 e0       	ldi	r24, 0x00	; 0
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	0f 91       	pop	r16
     704:	ff 90       	pop	r15
     706:	ef 90       	pop	r14
     708:	08 95       	ret

0000070a <prvHeapInit>:
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     70a:	e0 e9       	ldi	r30, 0x90	; 144
     70c:	f0 e0       	ldi	r31, 0x00	; 0
     70e:	85 e9       	ldi	r24, 0x95	; 149
     710:	90 e0       	ldi	r25, 0x00	; 0
     712:	91 83       	std	Z+1, r25	; 0x01
     714:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     716:	13 82       	std	Z+3, r1	; 0x03
     718:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     71a:	ec e8       	ldi	r30, 0x8C	; 140
     71c:	f0 e0       	ldi	r31, 0x00	; 0
     71e:	87 ee       	ldi	r24, 0xE7	; 231
     720:	93 e0       	ldi	r25, 0x03	; 3
     722:	93 83       	std	Z+3, r25	; 0x03
     724:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     726:	11 82       	std	Z+1, r1	; 0x01
     728:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     72a:	a4 e9       	ldi	r26, 0x94	; 148
     72c:	b0 e0       	ldi	r27, 0x00	; 0
     72e:	14 96       	adiw	r26, 0x04	; 4
     730:	9c 93       	st	X, r25
     732:	8e 93       	st	-X, r24
     734:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     736:	12 96       	adiw	r26, 0x02	; 2
     738:	fc 93       	st	X, r31
     73a:	ee 93       	st	-X, r30
     73c:	11 97       	sbiw	r26, 0x01	; 1
     73e:	08 95       	ret

00000740 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     740:	0f 93       	push	r16
     742:	1f 93       	push	r17
     744:	cf 93       	push	r28
     746:	df 93       	push	r29
     748:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     74a:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     74e:	80 91 8b 00 	lds	r24, 0x008B	; 0x80008b <xHeapHasBeenInitialised.2079>
     752:	81 11       	cpse	r24, r1
     754:	05 c0       	rjmp	.+10     	; 0x760 <pvPortMalloc+0x20>
		{
			prvHeapInit();
     756:	0e 94 85 03 	call	0x70a	; 0x70a <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
     75a:	81 e0       	ldi	r24, 0x01	; 1
     75c:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <xHeapHasBeenInitialised.2079>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     760:	20 97       	sbiw	r28, 0x00	; 0
     762:	09 f0       	breq	.+2      	; 0x766 <pvPortMalloc+0x26>
		{
			xWantedSize += heapSTRUCT_SIZE;
     764:	24 96       	adiw	r28, 0x04	; 4
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     766:	ce 01       	movw	r24, r28
     768:	01 97       	sbiw	r24, 0x01	; 1
     76a:	86 3e       	cpi	r24, 0xE6	; 230
     76c:	93 40       	sbci	r25, 0x03	; 3
     76e:	08 f0       	brcs	.+2      	; 0x772 <pvPortMalloc+0x32>
     770:	56 c0       	rjmp	.+172    	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     772:	e0 91 90 00 	lds	r30, 0x0090	; 0x800090 <xStart>
     776:	f0 91 91 00 	lds	r31, 0x0091	; 0x800091 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     77a:	a0 e9       	ldi	r26, 0x90	; 144
     77c:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     77e:	02 c0       	rjmp	.+4      	; 0x784 <pvPortMalloc+0x44>
			{
				pxPreviousBlock = pxBlock;
     780:	df 01       	movw	r26, r30
				pxBlock = pxBlock->pxNextFreeBlock;
     782:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     784:	82 81       	ldd	r24, Z+2	; 0x02
     786:	93 81       	ldd	r25, Z+3	; 0x03
     788:	8c 17       	cp	r24, r28
     78a:	9d 07       	cpc	r25, r29
     78c:	20 f4       	brcc	.+8      	; 0x796 <pvPortMalloc+0x56>
     78e:	80 81       	ld	r24, Z
     790:	91 81       	ldd	r25, Z+1	; 0x01
     792:	00 97       	sbiw	r24, 0x00	; 0
     794:	a9 f7       	brne	.-22     	; 0x780 <pvPortMalloc+0x40>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     796:	80 e0       	ldi	r24, 0x00	; 0
     798:	ec 38       	cpi	r30, 0x8C	; 140
     79a:	f8 07       	cpc	r31, r24
     79c:	09 f4       	brne	.+2      	; 0x7a0 <pvPortMalloc+0x60>
     79e:	42 c0       	rjmp	.+132    	; 0x824 <__DATA_REGION_LENGTH__+0x24>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     7a0:	0d 91       	ld	r16, X+
     7a2:	1c 91       	ld	r17, X
     7a4:	11 97       	sbiw	r26, 0x01	; 1
     7a6:	0c 5f       	subi	r16, 0xFC	; 252
     7a8:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     7aa:	80 81       	ld	r24, Z
     7ac:	91 81       	ldd	r25, Z+1	; 0x01
     7ae:	8d 93       	st	X+, r24
     7b0:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     7b2:	82 81       	ldd	r24, Z+2	; 0x02
     7b4:	93 81       	ldd	r25, Z+3	; 0x03
     7b6:	8c 1b       	sub	r24, r28
     7b8:	9d 0b       	sbc	r25, r29
     7ba:	89 30       	cpi	r24, 0x09	; 9
     7bc:	91 05       	cpc	r25, r1
     7be:	10 f1       	brcs	.+68     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     7c0:	af 01       	movw	r20, r30
     7c2:	4c 0f       	add	r20, r28
     7c4:	5d 1f       	adc	r21, r29

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     7c6:	da 01       	movw	r26, r20
     7c8:	13 96       	adiw	r26, 0x03	; 3
     7ca:	9c 93       	st	X, r25
     7cc:	8e 93       	st	-X, r24
     7ce:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     7d0:	d3 83       	std	Z+3, r29	; 0x03
     7d2:	c2 83       	std	Z+2, r28	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     7d4:	12 96       	adiw	r26, 0x02	; 2
     7d6:	2d 91       	ld	r18, X+
     7d8:	3c 91       	ld	r19, X
     7da:	13 97       	sbiw	r26, 0x03	; 3
     7dc:	60 e9       	ldi	r22, 0x90	; 144
     7de:	70 e0       	ldi	r23, 0x00	; 0
     7e0:	01 c0       	rjmp	.+2      	; 0x7e4 <pvPortMalloc+0xa4>
     7e2:	bd 01       	movw	r22, r26
     7e4:	eb 01       	movw	r28, r22
     7e6:	a8 81       	ld	r26, Y
     7e8:	b9 81       	ldd	r27, Y+1	; 0x01
     7ea:	12 96       	adiw	r26, 0x02	; 2
     7ec:	8d 91       	ld	r24, X+
     7ee:	9c 91       	ld	r25, X
     7f0:	13 97       	sbiw	r26, 0x03	; 3
     7f2:	82 17       	cp	r24, r18
     7f4:	93 07       	cpc	r25, r19
     7f6:	a8 f3       	brcs	.-22     	; 0x7e2 <pvPortMalloc+0xa2>
     7f8:	ea 01       	movw	r28, r20
     7fa:	b9 83       	std	Y+1, r27	; 0x01
     7fc:	a8 83       	st	Y, r26
     7fe:	db 01       	movw	r26, r22
     800:	4d 93       	st	X+, r20
     802:	5c 93       	st	X, r21
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     804:	22 81       	ldd	r18, Z+2	; 0x02
     806:	33 81       	ldd	r19, Z+3	; 0x03
     808:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     80c:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     810:	82 1b       	sub	r24, r18
     812:	93 0b       	sbc	r25, r19
     814:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     818:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     81c:	05 c0       	rjmp	.+10     	; 0x828 <__DATA_REGION_LENGTH__+0x28>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     81e:	00 e0       	ldi	r16, 0x00	; 0
     820:	10 e0       	ldi	r17, 0x00	; 0
     822:	02 c0       	rjmp	.+4      	; 0x828 <__DATA_REGION_LENGTH__+0x28>
     824:	00 e0       	ldi	r16, 0x00	; 0
     826:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     828:	0e 94 93 0b 	call	0x1726	; 0x1726 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     82c:	c8 01       	movw	r24, r16
     82e:	df 91       	pop	r29
     830:	cf 91       	pop	r28
     832:	1f 91       	pop	r17
     834:	0f 91       	pop	r16
     836:	08 95       	ret

00000838 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     838:	0f 93       	push	r16
     83a:	1f 93       	push	r17
     83c:	cf 93       	push	r28
     83e:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     840:	00 97       	sbiw	r24, 0x00	; 0
     842:	41 f1       	breq	.+80     	; 0x894 <__stack+0x35>
     844:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     846:	8c 01       	movw	r16, r24
     848:	04 50       	subi	r16, 0x04	; 4
     84a:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     84c:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     850:	f8 01       	movw	r30, r16
     852:	42 81       	ldd	r20, Z+2	; 0x02
     854:	53 81       	ldd	r21, Z+3	; 0x03
     856:	a0 e9       	ldi	r26, 0x90	; 144
     858:	b0 e0       	ldi	r27, 0x00	; 0
     85a:	01 c0       	rjmp	.+2      	; 0x85e <vPortFree+0x26>
     85c:	df 01       	movw	r26, r30
     85e:	ed 91       	ld	r30, X+
     860:	fc 91       	ld	r31, X
     862:	11 97       	sbiw	r26, 0x01	; 1
     864:	22 81       	ldd	r18, Z+2	; 0x02
     866:	33 81       	ldd	r19, Z+3	; 0x03
     868:	24 17       	cp	r18, r20
     86a:	35 07       	cpc	r19, r21
     86c:	b8 f3       	brcs	.-18     	; 0x85c <vPortFree+0x24>
     86e:	24 97       	sbiw	r28, 0x04	; 4
     870:	f9 83       	std	Y+1, r31	; 0x01
     872:	e8 83       	st	Y, r30
     874:	0d 93       	st	X+, r16
     876:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     878:	8a 81       	ldd	r24, Y+2	; 0x02
     87a:	9b 81       	ldd	r25, Y+3	; 0x03
     87c:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     880:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     884:	82 0f       	add	r24, r18
     886:	93 1f       	adc	r25, r19
     888:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     88c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     890:	0e 94 93 0b 	call	0x1726	; 0x1726 <xTaskResumeAll>
	}
}
     894:	df 91       	pop	r29
     896:	cf 91       	pop	r28
     898:	1f 91       	pop	r17
     89a:	0f 91       	pop	r16
     89c:	08 95       	ret

0000089e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     89e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8a0:	03 96       	adiw	r24, 0x03	; 3
     8a2:	92 83       	std	Z+2, r25	; 0x02
     8a4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8a6:	2f ef       	ldi	r18, 0xFF	; 255
     8a8:	3f ef       	ldi	r19, 0xFF	; 255
     8aa:	34 83       	std	Z+4, r19	; 0x04
     8ac:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8ae:	96 83       	std	Z+6, r25	; 0x06
     8b0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8b2:	90 87       	std	Z+8, r25	; 0x08
     8b4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8b6:	10 82       	st	Z, r1
     8b8:	08 95       	ret

000008ba <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8ba:	fc 01       	movw	r30, r24
     8bc:	11 86       	std	Z+9, r1	; 0x09
     8be:	10 86       	std	Z+8, r1	; 0x08
     8c0:	08 95       	ret

000008c2 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     8c2:	cf 93       	push	r28
     8c4:	df 93       	push	r29
     8c6:	9c 01       	movw	r18, r24
     8c8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     8ca:	dc 01       	movw	r26, r24
     8cc:	11 96       	adiw	r26, 0x01	; 1
     8ce:	cd 91       	ld	r28, X+
     8d0:	dc 91       	ld	r29, X
     8d2:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     8d4:	d3 83       	std	Z+3, r29	; 0x03
     8d6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     8d8:	8c 81       	ldd	r24, Y+4	; 0x04
     8da:	9d 81       	ldd	r25, Y+5	; 0x05
     8dc:	95 83       	std	Z+5, r25	; 0x05
     8de:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     8e0:	8c 81       	ldd	r24, Y+4	; 0x04
     8e2:	9d 81       	ldd	r25, Y+5	; 0x05
     8e4:	dc 01       	movw	r26, r24
     8e6:	13 96       	adiw	r26, 0x03	; 3
     8e8:	7c 93       	st	X, r23
     8ea:	6e 93       	st	-X, r22
     8ec:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     8ee:	7d 83       	std	Y+5, r23	; 0x05
     8f0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8f2:	31 87       	std	Z+9, r19	; 0x09
     8f4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     8f6:	f9 01       	movw	r30, r18
     8f8:	80 81       	ld	r24, Z
     8fa:	8f 5f       	subi	r24, 0xFF	; 255
     8fc:	80 83       	st	Z, r24
}
     8fe:	df 91       	pop	r29
     900:	cf 91       	pop	r28
     902:	08 95       	ret

00000904 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     904:	cf 93       	push	r28
     906:	df 93       	push	r29
     908:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     90a:	48 81       	ld	r20, Y
     90c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     90e:	4f 3f       	cpi	r20, 0xFF	; 255
     910:	2f ef       	ldi	r18, 0xFF	; 255
     912:	52 07       	cpc	r21, r18
     914:	21 f4       	brne	.+8      	; 0x91e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     916:	fc 01       	movw	r30, r24
     918:	a7 81       	ldd	r26, Z+7	; 0x07
     91a:	b0 85       	ldd	r27, Z+8	; 0x08
     91c:	0d c0       	rjmp	.+26     	; 0x938 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     91e:	dc 01       	movw	r26, r24
     920:	13 96       	adiw	r26, 0x03	; 3
     922:	01 c0       	rjmp	.+2      	; 0x926 <vListInsert+0x22>
     924:	df 01       	movw	r26, r30
     926:	12 96       	adiw	r26, 0x02	; 2
     928:	ed 91       	ld	r30, X+
     92a:	fc 91       	ld	r31, X
     92c:	13 97       	sbiw	r26, 0x03	; 3
     92e:	20 81       	ld	r18, Z
     930:	31 81       	ldd	r19, Z+1	; 0x01
     932:	42 17       	cp	r20, r18
     934:	53 07       	cpc	r21, r19
     936:	b0 f7       	brcc	.-20     	; 0x924 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     938:	12 96       	adiw	r26, 0x02	; 2
     93a:	ed 91       	ld	r30, X+
     93c:	fc 91       	ld	r31, X
     93e:	13 97       	sbiw	r26, 0x03	; 3
     940:	fb 83       	std	Y+3, r31	; 0x03
     942:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     944:	d5 83       	std	Z+5, r29	; 0x05
     946:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     948:	bd 83       	std	Y+5, r27	; 0x05
     94a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     94c:	13 96       	adiw	r26, 0x03	; 3
     94e:	dc 93       	st	X, r29
     950:	ce 93       	st	-X, r28
     952:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     954:	99 87       	std	Y+9, r25	; 0x09
     956:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     958:	fc 01       	movw	r30, r24
     95a:	20 81       	ld	r18, Z
     95c:	2f 5f       	subi	r18, 0xFF	; 255
     95e:	20 83       	st	Z, r18
}
     960:	df 91       	pop	r29
     962:	cf 91       	pop	r28
     964:	08 95       	ret

00000966 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     966:	cf 93       	push	r28
     968:	df 93       	push	r29
     96a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     96c:	a0 85       	ldd	r26, Z+8	; 0x08
     96e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     970:	c2 81       	ldd	r28, Z+2	; 0x02
     972:	d3 81       	ldd	r29, Z+3	; 0x03
     974:	84 81       	ldd	r24, Z+4	; 0x04
     976:	95 81       	ldd	r25, Z+5	; 0x05
     978:	9d 83       	std	Y+5, r25	; 0x05
     97a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     97c:	c4 81       	ldd	r28, Z+4	; 0x04
     97e:	d5 81       	ldd	r29, Z+5	; 0x05
     980:	82 81       	ldd	r24, Z+2	; 0x02
     982:	93 81       	ldd	r25, Z+3	; 0x03
     984:	9b 83       	std	Y+3, r25	; 0x03
     986:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     988:	11 96       	adiw	r26, 0x01	; 1
     98a:	8d 91       	ld	r24, X+
     98c:	9c 91       	ld	r25, X
     98e:	12 97       	sbiw	r26, 0x02	; 2
     990:	e8 17       	cp	r30, r24
     992:	f9 07       	cpc	r31, r25
     994:	31 f4       	brne	.+12     	; 0x9a2 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     996:	84 81       	ldd	r24, Z+4	; 0x04
     998:	95 81       	ldd	r25, Z+5	; 0x05
     99a:	12 96       	adiw	r26, 0x02	; 2
     99c:	9c 93       	st	X, r25
     99e:	8e 93       	st	-X, r24
     9a0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9a2:	11 86       	std	Z+9, r1	; 0x09
     9a4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     9a6:	8c 91       	ld	r24, X
     9a8:	81 50       	subi	r24, 0x01	; 1
     9aa:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     9ac:	df 91       	pop	r29
     9ae:	cf 91       	pop	r28
     9b0:	08 95       	ret

000009b2 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     9b2:	1b bc       	out	0x2b, r1	; 43
     9b4:	89 ef       	ldi	r24, 0xF9	; 249
     9b6:	8a bd       	out	0x2a, r24	; 42
     9b8:	8b e0       	ldi	r24, 0x0B	; 11
     9ba:	8e bd       	out	0x2e, r24	; 46
     9bc:	89 b7       	in	r24, 0x39	; 57
     9be:	80 61       	ori	r24, 0x10	; 16
     9c0:	89 bf       	out	0x39, r24	; 57
     9c2:	08 95       	ret

000009c4 <pxPortInitialiseStack>:
     9c4:	31 e1       	ldi	r19, 0x11	; 17
     9c6:	fc 01       	movw	r30, r24
     9c8:	30 83       	st	Z, r19
     9ca:	31 97       	sbiw	r30, 0x01	; 1
     9cc:	22 e2       	ldi	r18, 0x22	; 34
     9ce:	20 83       	st	Z, r18
     9d0:	31 97       	sbiw	r30, 0x01	; 1
     9d2:	a3 e3       	ldi	r26, 0x33	; 51
     9d4:	a0 83       	st	Z, r26
     9d6:	31 97       	sbiw	r30, 0x01	; 1
     9d8:	60 83       	st	Z, r22
     9da:	31 97       	sbiw	r30, 0x01	; 1
     9dc:	70 83       	st	Z, r23
     9de:	31 97       	sbiw	r30, 0x01	; 1
     9e0:	10 82       	st	Z, r1
     9e2:	31 97       	sbiw	r30, 0x01	; 1
     9e4:	60 e8       	ldi	r22, 0x80	; 128
     9e6:	60 83       	st	Z, r22
     9e8:	31 97       	sbiw	r30, 0x01	; 1
     9ea:	10 82       	st	Z, r1
     9ec:	31 97       	sbiw	r30, 0x01	; 1
     9ee:	62 e0       	ldi	r22, 0x02	; 2
     9f0:	60 83       	st	Z, r22
     9f2:	31 97       	sbiw	r30, 0x01	; 1
     9f4:	63 e0       	ldi	r22, 0x03	; 3
     9f6:	60 83       	st	Z, r22
     9f8:	31 97       	sbiw	r30, 0x01	; 1
     9fa:	64 e0       	ldi	r22, 0x04	; 4
     9fc:	60 83       	st	Z, r22
     9fe:	31 97       	sbiw	r30, 0x01	; 1
     a00:	65 e0       	ldi	r22, 0x05	; 5
     a02:	60 83       	st	Z, r22
     a04:	31 97       	sbiw	r30, 0x01	; 1
     a06:	66 e0       	ldi	r22, 0x06	; 6
     a08:	60 83       	st	Z, r22
     a0a:	31 97       	sbiw	r30, 0x01	; 1
     a0c:	67 e0       	ldi	r22, 0x07	; 7
     a0e:	60 83       	st	Z, r22
     a10:	31 97       	sbiw	r30, 0x01	; 1
     a12:	68 e0       	ldi	r22, 0x08	; 8
     a14:	60 83       	st	Z, r22
     a16:	31 97       	sbiw	r30, 0x01	; 1
     a18:	69 e0       	ldi	r22, 0x09	; 9
     a1a:	60 83       	st	Z, r22
     a1c:	31 97       	sbiw	r30, 0x01	; 1
     a1e:	60 e1       	ldi	r22, 0x10	; 16
     a20:	60 83       	st	Z, r22
     a22:	31 97       	sbiw	r30, 0x01	; 1
     a24:	30 83       	st	Z, r19
     a26:	31 97       	sbiw	r30, 0x01	; 1
     a28:	32 e1       	ldi	r19, 0x12	; 18
     a2a:	30 83       	st	Z, r19
     a2c:	31 97       	sbiw	r30, 0x01	; 1
     a2e:	33 e1       	ldi	r19, 0x13	; 19
     a30:	30 83       	st	Z, r19
     a32:	31 97       	sbiw	r30, 0x01	; 1
     a34:	34 e1       	ldi	r19, 0x14	; 20
     a36:	30 83       	st	Z, r19
     a38:	31 97       	sbiw	r30, 0x01	; 1
     a3a:	35 e1       	ldi	r19, 0x15	; 21
     a3c:	30 83       	st	Z, r19
     a3e:	31 97       	sbiw	r30, 0x01	; 1
     a40:	36 e1       	ldi	r19, 0x16	; 22
     a42:	30 83       	st	Z, r19
     a44:	31 97       	sbiw	r30, 0x01	; 1
     a46:	37 e1       	ldi	r19, 0x17	; 23
     a48:	30 83       	st	Z, r19
     a4a:	31 97       	sbiw	r30, 0x01	; 1
     a4c:	38 e1       	ldi	r19, 0x18	; 24
     a4e:	30 83       	st	Z, r19
     a50:	31 97       	sbiw	r30, 0x01	; 1
     a52:	39 e1       	ldi	r19, 0x19	; 25
     a54:	30 83       	st	Z, r19
     a56:	31 97       	sbiw	r30, 0x01	; 1
     a58:	30 e2       	ldi	r19, 0x20	; 32
     a5a:	30 83       	st	Z, r19
     a5c:	31 97       	sbiw	r30, 0x01	; 1
     a5e:	31 e2       	ldi	r19, 0x21	; 33
     a60:	30 83       	st	Z, r19
     a62:	31 97       	sbiw	r30, 0x01	; 1
     a64:	20 83       	st	Z, r18
     a66:	31 97       	sbiw	r30, 0x01	; 1
     a68:	23 e2       	ldi	r18, 0x23	; 35
     a6a:	20 83       	st	Z, r18
     a6c:	31 97       	sbiw	r30, 0x01	; 1
     a6e:	40 83       	st	Z, r20
     a70:	31 97       	sbiw	r30, 0x01	; 1
     a72:	50 83       	st	Z, r21
     a74:	31 97       	sbiw	r30, 0x01	; 1
     a76:	26 e2       	ldi	r18, 0x26	; 38
     a78:	20 83       	st	Z, r18
     a7a:	31 97       	sbiw	r30, 0x01	; 1
     a7c:	27 e2       	ldi	r18, 0x27	; 39
     a7e:	20 83       	st	Z, r18
     a80:	31 97       	sbiw	r30, 0x01	; 1
     a82:	28 e2       	ldi	r18, 0x28	; 40
     a84:	20 83       	st	Z, r18
     a86:	31 97       	sbiw	r30, 0x01	; 1
     a88:	29 e2       	ldi	r18, 0x29	; 41
     a8a:	20 83       	st	Z, r18
     a8c:	31 97       	sbiw	r30, 0x01	; 1
     a8e:	20 e3       	ldi	r18, 0x30	; 48
     a90:	20 83       	st	Z, r18
     a92:	31 97       	sbiw	r30, 0x01	; 1
     a94:	21 e3       	ldi	r18, 0x31	; 49
     a96:	20 83       	st	Z, r18
     a98:	86 97       	sbiw	r24, 0x26	; 38
     a9a:	08 95       	ret

00000a9c <xPortStartScheduler>:
     a9c:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <prvSetupTimerInterrupt>
     aa0:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <pxCurrentTCB>
     aa4:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
     aa8:	cd 91       	ld	r28, X+
     aaa:	cd bf       	out	0x3d, r28	; 61
     aac:	dd 91       	ld	r29, X+
     aae:	de bf       	out	0x3e, r29	; 62
     ab0:	ff 91       	pop	r31
     ab2:	ef 91       	pop	r30
     ab4:	df 91       	pop	r29
     ab6:	cf 91       	pop	r28
     ab8:	bf 91       	pop	r27
     aba:	af 91       	pop	r26
     abc:	9f 91       	pop	r25
     abe:	8f 91       	pop	r24
     ac0:	7f 91       	pop	r23
     ac2:	6f 91       	pop	r22
     ac4:	5f 91       	pop	r21
     ac6:	4f 91       	pop	r20
     ac8:	3f 91       	pop	r19
     aca:	2f 91       	pop	r18
     acc:	1f 91       	pop	r17
     ace:	0f 91       	pop	r16
     ad0:	ff 90       	pop	r15
     ad2:	ef 90       	pop	r14
     ad4:	df 90       	pop	r13
     ad6:	cf 90       	pop	r12
     ad8:	bf 90       	pop	r11
     ada:	af 90       	pop	r10
     adc:	9f 90       	pop	r9
     ade:	8f 90       	pop	r8
     ae0:	7f 90       	pop	r7
     ae2:	6f 90       	pop	r6
     ae4:	5f 90       	pop	r5
     ae6:	4f 90       	pop	r4
     ae8:	3f 90       	pop	r3
     aea:	2f 90       	pop	r2
     aec:	1f 90       	pop	r1
     aee:	0f 90       	pop	r0
     af0:	0f be       	out	0x3f, r0	; 63
     af2:	0f 90       	pop	r0
     af4:	08 95       	ret
     af6:	81 e0       	ldi	r24, 0x01	; 1
     af8:	08 95       	ret

00000afa <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     afa:	0f 92       	push	r0
     afc:	0f b6       	in	r0, 0x3f	; 63
     afe:	f8 94       	cli
     b00:	0f 92       	push	r0
     b02:	1f 92       	push	r1
     b04:	11 24       	eor	r1, r1
     b06:	2f 92       	push	r2
     b08:	3f 92       	push	r3
     b0a:	4f 92       	push	r4
     b0c:	5f 92       	push	r5
     b0e:	6f 92       	push	r6
     b10:	7f 92       	push	r7
     b12:	8f 92       	push	r8
     b14:	9f 92       	push	r9
     b16:	af 92       	push	r10
     b18:	bf 92       	push	r11
     b1a:	cf 92       	push	r12
     b1c:	df 92       	push	r13
     b1e:	ef 92       	push	r14
     b20:	ff 92       	push	r15
     b22:	0f 93       	push	r16
     b24:	1f 93       	push	r17
     b26:	2f 93       	push	r18
     b28:	3f 93       	push	r19
     b2a:	4f 93       	push	r20
     b2c:	5f 93       	push	r21
     b2e:	6f 93       	push	r22
     b30:	7f 93       	push	r23
     b32:	8f 93       	push	r24
     b34:	9f 93       	push	r25
     b36:	af 93       	push	r26
     b38:	bf 93       	push	r27
     b3a:	cf 93       	push	r28
     b3c:	df 93       	push	r29
     b3e:	ef 93       	push	r30
     b40:	ff 93       	push	r31
     b42:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <pxCurrentTCB>
     b46:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
     b4a:	0d b6       	in	r0, 0x3d	; 61
     b4c:	0d 92       	st	X+, r0
     b4e:	0e b6       	in	r0, 0x3e	; 62
     b50:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     b52:	0e 94 4c 0c 	call	0x1898	; 0x1898 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b56:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <pxCurrentTCB>
     b5a:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
     b5e:	cd 91       	ld	r28, X+
     b60:	cd bf       	out	0x3d, r28	; 61
     b62:	dd 91       	ld	r29, X+
     b64:	de bf       	out	0x3e, r29	; 62
     b66:	ff 91       	pop	r31
     b68:	ef 91       	pop	r30
     b6a:	df 91       	pop	r29
     b6c:	cf 91       	pop	r28
     b6e:	bf 91       	pop	r27
     b70:	af 91       	pop	r26
     b72:	9f 91       	pop	r25
     b74:	8f 91       	pop	r24
     b76:	7f 91       	pop	r23
     b78:	6f 91       	pop	r22
     b7a:	5f 91       	pop	r21
     b7c:	4f 91       	pop	r20
     b7e:	3f 91       	pop	r19
     b80:	2f 91       	pop	r18
     b82:	1f 91       	pop	r17
     b84:	0f 91       	pop	r16
     b86:	ff 90       	pop	r15
     b88:	ef 90       	pop	r14
     b8a:	df 90       	pop	r13
     b8c:	cf 90       	pop	r12
     b8e:	bf 90       	pop	r11
     b90:	af 90       	pop	r10
     b92:	9f 90       	pop	r9
     b94:	8f 90       	pop	r8
     b96:	7f 90       	pop	r7
     b98:	6f 90       	pop	r6
     b9a:	5f 90       	pop	r5
     b9c:	4f 90       	pop	r4
     b9e:	3f 90       	pop	r3
     ba0:	2f 90       	pop	r2
     ba2:	1f 90       	pop	r1
     ba4:	0f 90       	pop	r0
     ba6:	0f be       	out	0x3f, r0	; 63
     ba8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     baa:	08 95       	ret

00000bac <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     bac:	0f 92       	push	r0
     bae:	0f b6       	in	r0, 0x3f	; 63
     bb0:	f8 94       	cli
     bb2:	0f 92       	push	r0
     bb4:	1f 92       	push	r1
     bb6:	11 24       	eor	r1, r1
     bb8:	2f 92       	push	r2
     bba:	3f 92       	push	r3
     bbc:	4f 92       	push	r4
     bbe:	5f 92       	push	r5
     bc0:	6f 92       	push	r6
     bc2:	7f 92       	push	r7
     bc4:	8f 92       	push	r8
     bc6:	9f 92       	push	r9
     bc8:	af 92       	push	r10
     bca:	bf 92       	push	r11
     bcc:	cf 92       	push	r12
     bce:	df 92       	push	r13
     bd0:	ef 92       	push	r14
     bd2:	ff 92       	push	r15
     bd4:	0f 93       	push	r16
     bd6:	1f 93       	push	r17
     bd8:	2f 93       	push	r18
     bda:	3f 93       	push	r19
     bdc:	4f 93       	push	r20
     bde:	5f 93       	push	r21
     be0:	6f 93       	push	r22
     be2:	7f 93       	push	r23
     be4:	8f 93       	push	r24
     be6:	9f 93       	push	r25
     be8:	af 93       	push	r26
     bea:	bf 93       	push	r27
     bec:	cf 93       	push	r28
     bee:	df 93       	push	r29
     bf0:	ef 93       	push	r30
     bf2:	ff 93       	push	r31
     bf4:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <pxCurrentTCB>
     bf8:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
     bfc:	0d b6       	in	r0, 0x3d	; 61
     bfe:	0d 92       	st	X+, r0
     c00:	0e b6       	in	r0, 0x3e	; 62
     c02:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     c04:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <xTaskIncrementTick>
     c08:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     c0a:	0e 94 4c 0c 	call	0x1898	; 0x1898 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     c0e:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <pxCurrentTCB>
     c12:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
     c16:	cd 91       	ld	r28, X+
     c18:	cd bf       	out	0x3d, r28	; 61
     c1a:	dd 91       	ld	r29, X+
     c1c:	de bf       	out	0x3e, r29	; 62
     c1e:	ff 91       	pop	r31
     c20:	ef 91       	pop	r30
     c22:	df 91       	pop	r29
     c24:	cf 91       	pop	r28
     c26:	bf 91       	pop	r27
     c28:	af 91       	pop	r26
     c2a:	9f 91       	pop	r25
     c2c:	8f 91       	pop	r24
     c2e:	7f 91       	pop	r23
     c30:	6f 91       	pop	r22
     c32:	5f 91       	pop	r21
     c34:	4f 91       	pop	r20
     c36:	3f 91       	pop	r19
     c38:	2f 91       	pop	r18
     c3a:	1f 91       	pop	r17
     c3c:	0f 91       	pop	r16
     c3e:	ff 90       	pop	r15
     c40:	ef 90       	pop	r14
     c42:	df 90       	pop	r13
     c44:	cf 90       	pop	r12
     c46:	bf 90       	pop	r11
     c48:	af 90       	pop	r10
     c4a:	9f 90       	pop	r9
     c4c:	8f 90       	pop	r8
     c4e:	7f 90       	pop	r7
     c50:	6f 90       	pop	r6
     c52:	5f 90       	pop	r5
     c54:	4f 90       	pop	r4
     c56:	3f 90       	pop	r3
     c58:	2f 90       	pop	r2
     c5a:	1f 90       	pop	r1
     c5c:	0f 90       	pop	r0
     c5e:	0f be       	out	0x3f, r0	; 63
     c60:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c62:	08 95       	ret

00000c64 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     c64:	0e 94 d6 05 	call	0xbac	; 0xbac <vPortYieldFromTick>
		asm volatile ( "reti" );
     c68:	18 95       	reti

00000c6a <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     c6a:	0f b6       	in	r0, 0x3f	; 63
     c6c:	f8 94       	cli
     c6e:	0f 92       	push	r0
     c70:	fc 01       	movw	r30, r24
     c72:	82 8d       	ldd	r24, Z+26	; 0x1a
     c74:	81 11       	cpse	r24, r1
     c76:	02 c0       	rjmp	.+4      	; 0xc7c <prvIsQueueEmpty+0x12>
     c78:	81 e0       	ldi	r24, 0x01	; 1
     c7a:	01 c0       	rjmp	.+2      	; 0xc7e <prvIsQueueEmpty+0x14>
     c7c:	80 e0       	ldi	r24, 0x00	; 0
     c7e:	0f 90       	pop	r0
     c80:	0f be       	out	0x3f, r0	; 63
     c82:	08 95       	ret

00000c84 <prvIsQueueFull>:
     c84:	0f b6       	in	r0, 0x3f	; 63
     c86:	f8 94       	cli
     c88:	0f 92       	push	r0
     c8a:	fc 01       	movw	r30, r24
     c8c:	22 8d       	ldd	r18, Z+26	; 0x1a
     c8e:	83 8d       	ldd	r24, Z+27	; 0x1b
     c90:	28 13       	cpse	r18, r24
     c92:	02 c0       	rjmp	.+4      	; 0xc98 <prvIsQueueFull+0x14>
     c94:	81 e0       	ldi	r24, 0x01	; 1
     c96:	01 c0       	rjmp	.+2      	; 0xc9a <prvIsQueueFull+0x16>
     c98:	80 e0       	ldi	r24, 0x00	; 0
     c9a:	0f 90       	pop	r0
     c9c:	0f be       	out	0x3f, r0	; 63
     c9e:	08 95       	ret

00000ca0 <prvCopyDataToQueue>:
     ca0:	0f 93       	push	r16
     ca2:	1f 93       	push	r17
     ca4:	cf 93       	push	r28
     ca6:	df 93       	push	r29
     ca8:	ec 01       	movw	r28, r24
     caa:	04 2f       	mov	r16, r20
     cac:	1a 8d       	ldd	r17, Y+26	; 0x1a
     cae:	4c 8d       	ldd	r20, Y+28	; 0x1c
     cb0:	41 11       	cpse	r20, r1
     cb2:	0c c0       	rjmp	.+24     	; 0xccc <prvCopyDataToQueue+0x2c>
     cb4:	88 81       	ld	r24, Y
     cb6:	99 81       	ldd	r25, Y+1	; 0x01
     cb8:	89 2b       	or	r24, r25
     cba:	09 f0       	breq	.+2      	; 0xcbe <prvCopyDataToQueue+0x1e>
     cbc:	42 c0       	rjmp	.+132    	; 0xd42 <prvCopyDataToQueue+0xa2>
     cbe:	8a 81       	ldd	r24, Y+2	; 0x02
     cc0:	9b 81       	ldd	r25, Y+3	; 0x03
     cc2:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xTaskPriorityDisinherit>
     cc6:	1b 82       	std	Y+3, r1	; 0x03
     cc8:	1a 82       	std	Y+2, r1	; 0x02
     cca:	42 c0       	rjmp	.+132    	; 0xd50 <prvCopyDataToQueue+0xb0>
     ccc:	01 11       	cpse	r16, r1
     cce:	17 c0       	rjmp	.+46     	; 0xcfe <prvCopyDataToQueue+0x5e>
     cd0:	50 e0       	ldi	r21, 0x00	; 0
     cd2:	8c 81       	ldd	r24, Y+4	; 0x04
     cd4:	9d 81       	ldd	r25, Y+5	; 0x05
     cd6:	0e 94 ba 13 	call	0x2774	; 0x2774 <memcpy>
     cda:	2c 8d       	ldd	r18, Y+28	; 0x1c
     cdc:	8c 81       	ldd	r24, Y+4	; 0x04
     cde:	9d 81       	ldd	r25, Y+5	; 0x05
     ce0:	82 0f       	add	r24, r18
     ce2:	91 1d       	adc	r25, r1
     ce4:	9d 83       	std	Y+5, r25	; 0x05
     ce6:	8c 83       	std	Y+4, r24	; 0x04
     ce8:	2a 81       	ldd	r18, Y+2	; 0x02
     cea:	3b 81       	ldd	r19, Y+3	; 0x03
     cec:	82 17       	cp	r24, r18
     cee:	93 07       	cpc	r25, r19
     cf0:	50 f1       	brcs	.+84     	; 0xd46 <prvCopyDataToQueue+0xa6>
     cf2:	88 81       	ld	r24, Y
     cf4:	99 81       	ldd	r25, Y+1	; 0x01
     cf6:	9d 83       	std	Y+5, r25	; 0x05
     cf8:	8c 83       	std	Y+4, r24	; 0x04
     cfa:	80 e0       	ldi	r24, 0x00	; 0
     cfc:	29 c0       	rjmp	.+82     	; 0xd50 <prvCopyDataToQueue+0xb0>
     cfe:	50 e0       	ldi	r21, 0x00	; 0
     d00:	8e 81       	ldd	r24, Y+6	; 0x06
     d02:	9f 81       	ldd	r25, Y+7	; 0x07
     d04:	0e 94 ba 13 	call	0x2774	; 0x2774 <memcpy>
     d08:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d0a:	90 e0       	ldi	r25, 0x00	; 0
     d0c:	91 95       	neg	r25
     d0e:	81 95       	neg	r24
     d10:	91 09       	sbc	r25, r1
     d12:	2e 81       	ldd	r18, Y+6	; 0x06
     d14:	3f 81       	ldd	r19, Y+7	; 0x07
     d16:	28 0f       	add	r18, r24
     d18:	39 1f       	adc	r19, r25
     d1a:	3f 83       	std	Y+7, r19	; 0x07
     d1c:	2e 83       	std	Y+6, r18	; 0x06
     d1e:	48 81       	ld	r20, Y
     d20:	59 81       	ldd	r21, Y+1	; 0x01
     d22:	24 17       	cp	r18, r20
     d24:	35 07       	cpc	r19, r21
     d26:	30 f4       	brcc	.+12     	; 0xd34 <prvCopyDataToQueue+0x94>
     d28:	2a 81       	ldd	r18, Y+2	; 0x02
     d2a:	3b 81       	ldd	r19, Y+3	; 0x03
     d2c:	82 0f       	add	r24, r18
     d2e:	93 1f       	adc	r25, r19
     d30:	9f 83       	std	Y+7, r25	; 0x07
     d32:	8e 83       	std	Y+6, r24	; 0x06
     d34:	02 30       	cpi	r16, 0x02	; 2
     d36:	49 f4       	brne	.+18     	; 0xd4a <prvCopyDataToQueue+0xaa>
     d38:	11 23       	and	r17, r17
     d3a:	49 f0       	breq	.+18     	; 0xd4e <prvCopyDataToQueue+0xae>
     d3c:	11 50       	subi	r17, 0x01	; 1
     d3e:	80 e0       	ldi	r24, 0x00	; 0
     d40:	07 c0       	rjmp	.+14     	; 0xd50 <prvCopyDataToQueue+0xb0>
     d42:	80 e0       	ldi	r24, 0x00	; 0
     d44:	05 c0       	rjmp	.+10     	; 0xd50 <prvCopyDataToQueue+0xb0>
     d46:	80 e0       	ldi	r24, 0x00	; 0
     d48:	03 c0       	rjmp	.+6      	; 0xd50 <prvCopyDataToQueue+0xb0>
     d4a:	80 e0       	ldi	r24, 0x00	; 0
     d4c:	01 c0       	rjmp	.+2      	; 0xd50 <prvCopyDataToQueue+0xb0>
     d4e:	80 e0       	ldi	r24, 0x00	; 0
     d50:	1f 5f       	subi	r17, 0xFF	; 255
     d52:	1a 8f       	std	Y+26, r17	; 0x1a
     d54:	df 91       	pop	r29
     d56:	cf 91       	pop	r28
     d58:	1f 91       	pop	r17
     d5a:	0f 91       	pop	r16
     d5c:	08 95       	ret

00000d5e <prvCopyDataFromQueue>:
     d5e:	fc 01       	movw	r30, r24
     d60:	44 8d       	ldd	r20, Z+28	; 0x1c
     d62:	44 23       	and	r20, r20
     d64:	a9 f0       	breq	.+42     	; 0xd90 <prvCopyDataFromQueue+0x32>
     d66:	50 e0       	ldi	r21, 0x00	; 0
     d68:	26 81       	ldd	r18, Z+6	; 0x06
     d6a:	37 81       	ldd	r19, Z+7	; 0x07
     d6c:	24 0f       	add	r18, r20
     d6e:	35 1f       	adc	r19, r21
     d70:	37 83       	std	Z+7, r19	; 0x07
     d72:	26 83       	std	Z+6, r18	; 0x06
     d74:	82 81       	ldd	r24, Z+2	; 0x02
     d76:	93 81       	ldd	r25, Z+3	; 0x03
     d78:	28 17       	cp	r18, r24
     d7a:	39 07       	cpc	r19, r25
     d7c:	20 f0       	brcs	.+8      	; 0xd86 <prvCopyDataFromQueue+0x28>
     d7e:	80 81       	ld	r24, Z
     d80:	91 81       	ldd	r25, Z+1	; 0x01
     d82:	97 83       	std	Z+7, r25	; 0x07
     d84:	86 83       	std	Z+6, r24	; 0x06
     d86:	cb 01       	movw	r24, r22
     d88:	66 81       	ldd	r22, Z+6	; 0x06
     d8a:	77 81       	ldd	r23, Z+7	; 0x07
     d8c:	0e 94 ba 13 	call	0x2774	; 0x2774 <memcpy>
     d90:	08 95       	ret

00000d92 <prvUnlockQueue>:
     d92:	1f 93       	push	r17
     d94:	cf 93       	push	r28
     d96:	df 93       	push	r29
     d98:	ec 01       	movw	r28, r24
     d9a:	0f b6       	in	r0, 0x3f	; 63
     d9c:	f8 94       	cli
     d9e:	0f 92       	push	r0
     da0:	1e 8d       	ldd	r17, Y+30	; 0x1e
     da2:	0b c0       	rjmp	.+22     	; 0xdba <prvUnlockQueue+0x28>
     da4:	89 89       	ldd	r24, Y+17	; 0x11
     da6:	88 23       	and	r24, r24
     da8:	51 f0       	breq	.+20     	; 0xdbe <prvUnlockQueue+0x2c>
     daa:	ce 01       	movw	r24, r28
     dac:	41 96       	adiw	r24, 0x11	; 17
     dae:	0e 94 b2 0c 	call	0x1964	; 0x1964 <xTaskRemoveFromEventList>
     db2:	81 11       	cpse	r24, r1
     db4:	0e 94 3e 0d 	call	0x1a7c	; 0x1a7c <vTaskMissedYield>
     db8:	11 50       	subi	r17, 0x01	; 1
     dba:	11 16       	cp	r1, r17
     dbc:	9c f3       	brlt	.-26     	; 0xda4 <prvUnlockQueue+0x12>
     dbe:	8f ef       	ldi	r24, 0xFF	; 255
     dc0:	8e 8f       	std	Y+30, r24	; 0x1e
     dc2:	0f 90       	pop	r0
     dc4:	0f be       	out	0x3f, r0	; 63
     dc6:	0f b6       	in	r0, 0x3f	; 63
     dc8:	f8 94       	cli
     dca:	0f 92       	push	r0
     dcc:	1d 8d       	ldd	r17, Y+29	; 0x1d
     dce:	0b c0       	rjmp	.+22     	; 0xde6 <prvUnlockQueue+0x54>
     dd0:	88 85       	ldd	r24, Y+8	; 0x08
     dd2:	88 23       	and	r24, r24
     dd4:	51 f0       	breq	.+20     	; 0xdea <prvUnlockQueue+0x58>
     dd6:	ce 01       	movw	r24, r28
     dd8:	08 96       	adiw	r24, 0x08	; 8
     dda:	0e 94 b2 0c 	call	0x1964	; 0x1964 <xTaskRemoveFromEventList>
     dde:	81 11       	cpse	r24, r1
     de0:	0e 94 3e 0d 	call	0x1a7c	; 0x1a7c <vTaskMissedYield>
     de4:	11 50       	subi	r17, 0x01	; 1
     de6:	11 16       	cp	r1, r17
     de8:	9c f3       	brlt	.-26     	; 0xdd0 <prvUnlockQueue+0x3e>
     dea:	8f ef       	ldi	r24, 0xFF	; 255
     dec:	8d 8f       	std	Y+29, r24	; 0x1d
     dee:	0f 90       	pop	r0
     df0:	0f be       	out	0x3f, r0	; 63
     df2:	df 91       	pop	r29
     df4:	cf 91       	pop	r28
     df6:	1f 91       	pop	r17
     df8:	08 95       	ret

00000dfa <xQueueGenericReset>:
     dfa:	cf 93       	push	r28
     dfc:	df 93       	push	r29
     dfe:	ec 01       	movw	r28, r24
     e00:	0f b6       	in	r0, 0x3f	; 63
     e02:	f8 94       	cli
     e04:	0f 92       	push	r0
     e06:	e8 81       	ld	r30, Y
     e08:	f9 81       	ldd	r31, Y+1	; 0x01
     e0a:	8b 8d       	ldd	r24, Y+27	; 0x1b
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e10:	30 e0       	ldi	r19, 0x00	; 0
     e12:	82 9f       	mul	r24, r18
     e14:	a0 01       	movw	r20, r0
     e16:	83 9f       	mul	r24, r19
     e18:	50 0d       	add	r21, r0
     e1a:	92 9f       	mul	r25, r18
     e1c:	50 0d       	add	r21, r0
     e1e:	11 24       	eor	r1, r1
     e20:	4e 0f       	add	r20, r30
     e22:	5f 1f       	adc	r21, r31
     e24:	5b 83       	std	Y+3, r21	; 0x03
     e26:	4a 83       	std	Y+2, r20	; 0x02
     e28:	1a 8e       	std	Y+26, r1	; 0x1a
     e2a:	fd 83       	std	Y+5, r31	; 0x05
     e2c:	ec 83       	std	Y+4, r30	; 0x04
     e2e:	01 97       	sbiw	r24, 0x01	; 1
     e30:	28 9f       	mul	r18, r24
     e32:	a0 01       	movw	r20, r0
     e34:	29 9f       	mul	r18, r25
     e36:	50 0d       	add	r21, r0
     e38:	38 9f       	mul	r19, r24
     e3a:	50 0d       	add	r21, r0
     e3c:	11 24       	eor	r1, r1
     e3e:	cf 01       	movw	r24, r30
     e40:	84 0f       	add	r24, r20
     e42:	95 1f       	adc	r25, r21
     e44:	9f 83       	std	Y+7, r25	; 0x07
     e46:	8e 83       	std	Y+6, r24	; 0x06
     e48:	8f ef       	ldi	r24, 0xFF	; 255
     e4a:	8d 8f       	std	Y+29, r24	; 0x1d
     e4c:	8e 8f       	std	Y+30, r24	; 0x1e
     e4e:	61 11       	cpse	r22, r1
     e50:	0c c0       	rjmp	.+24     	; 0xe6a <xQueueGenericReset+0x70>
     e52:	88 85       	ldd	r24, Y+8	; 0x08
     e54:	88 23       	and	r24, r24
     e56:	89 f0       	breq	.+34     	; 0xe7a <xQueueGenericReset+0x80>
     e58:	ce 01       	movw	r24, r28
     e5a:	08 96       	adiw	r24, 0x08	; 8
     e5c:	0e 94 b2 0c 	call	0x1964	; 0x1964 <xTaskRemoveFromEventList>
     e60:	88 23       	and	r24, r24
     e62:	59 f0       	breq	.+22     	; 0xe7a <xQueueGenericReset+0x80>
     e64:	0e 94 7d 05 	call	0xafa	; 0xafa <vPortYield>
     e68:	08 c0       	rjmp	.+16     	; 0xe7a <xQueueGenericReset+0x80>
     e6a:	ce 01       	movw	r24, r28
     e6c:	08 96       	adiw	r24, 0x08	; 8
     e6e:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialise>
     e72:	ce 01       	movw	r24, r28
     e74:	41 96       	adiw	r24, 0x11	; 17
     e76:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialise>
     e7a:	0f 90       	pop	r0
     e7c:	0f be       	out	0x3f, r0	; 63
     e7e:	81 e0       	ldi	r24, 0x01	; 1
     e80:	df 91       	pop	r29
     e82:	cf 91       	pop	r28
     e84:	08 95       	ret

00000e86 <prvInitialiseNewQueue>:
     e86:	0f 93       	push	r16
     e88:	1f 93       	push	r17
     e8a:	f8 01       	movw	r30, r16
     e8c:	61 11       	cpse	r22, r1
     e8e:	03 c0       	rjmp	.+6      	; 0xe96 <prvInitialiseNewQueue+0x10>
     e90:	11 83       	std	Z+1, r17	; 0x01
     e92:	00 83       	st	Z, r16
     e94:	02 c0       	rjmp	.+4      	; 0xe9a <prvInitialiseNewQueue+0x14>
     e96:	51 83       	std	Z+1, r21	; 0x01
     e98:	40 83       	st	Z, r20
     e9a:	83 8f       	std	Z+27, r24	; 0x1b
     e9c:	64 8f       	std	Z+28, r22	; 0x1c
     e9e:	61 e0       	ldi	r22, 0x01	; 1
     ea0:	cf 01       	movw	r24, r30
     ea2:	0e 94 fd 06 	call	0xdfa	; 0xdfa <xQueueGenericReset>
     ea6:	1f 91       	pop	r17
     ea8:	0f 91       	pop	r16
     eaa:	08 95       	ret

00000eac <xQueueGenericCreate>:
     eac:	df 92       	push	r13
     eae:	ef 92       	push	r14
     eb0:	ff 92       	push	r15
     eb2:	0f 93       	push	r16
     eb4:	1f 93       	push	r17
     eb6:	cf 93       	push	r28
     eb8:	df 93       	push	r29
     eba:	e8 2e       	mov	r14, r24
     ebc:	f6 2e       	mov	r15, r22
     ebe:	d4 2e       	mov	r13, r20
     ec0:	66 23       	and	r22, r22
     ec2:	21 f0       	breq	.+8      	; 0xecc <xQueueGenericCreate+0x20>
     ec4:	86 9f       	mul	r24, r22
     ec6:	c0 01       	movw	r24, r0
     ec8:	11 24       	eor	r1, r1
     eca:	02 c0       	rjmp	.+4      	; 0xed0 <xQueueGenericCreate+0x24>
     ecc:	80 e0       	ldi	r24, 0x00	; 0
     ece:	90 e0       	ldi	r25, 0x00	; 0
     ed0:	4f 96       	adiw	r24, 0x1f	; 31
     ed2:	0e 94 a0 03 	call	0x740	; 0x740 <pvPortMalloc>
     ed6:	ec 01       	movw	r28, r24
     ed8:	00 97       	sbiw	r24, 0x00	; 0
     eda:	49 f0       	breq	.+18     	; 0xeee <xQueueGenericCreate+0x42>
     edc:	8c 01       	movw	r16, r24
     ede:	2d 2d       	mov	r18, r13
     ee0:	ac 01       	movw	r20, r24
     ee2:	41 5e       	subi	r20, 0xE1	; 225
     ee4:	5f 4f       	sbci	r21, 0xFF	; 255
     ee6:	6f 2d       	mov	r22, r15
     ee8:	8e 2d       	mov	r24, r14
     eea:	0e 94 43 07 	call	0xe86	; 0xe86 <prvInitialiseNewQueue>
     eee:	ce 01       	movw	r24, r28
     ef0:	df 91       	pop	r29
     ef2:	cf 91       	pop	r28
     ef4:	1f 91       	pop	r17
     ef6:	0f 91       	pop	r16
     ef8:	ff 90       	pop	r15
     efa:	ef 90       	pop	r14
     efc:	df 90       	pop	r13
     efe:	08 95       	ret

00000f00 <xQueueGenericSend>:
     f00:	cf 92       	push	r12
     f02:	df 92       	push	r13
     f04:	ef 92       	push	r14
     f06:	ff 92       	push	r15
     f08:	0f 93       	push	r16
     f0a:	1f 93       	push	r17
     f0c:	cf 93       	push	r28
     f0e:	df 93       	push	r29
     f10:	00 d0       	rcall	.+0      	; 0xf12 <xQueueGenericSend+0x12>
     f12:	00 d0       	rcall	.+0      	; 0xf14 <xQueueGenericSend+0x14>
     f14:	1f 92       	push	r1
     f16:	cd b7       	in	r28, 0x3d	; 61
     f18:	de b7       	in	r29, 0x3e	; 62
     f1a:	8c 01       	movw	r16, r24
     f1c:	7b 01       	movw	r14, r22
     f1e:	5d 83       	std	Y+5, r21	; 0x05
     f20:	4c 83       	std	Y+4, r20	; 0x04
     f22:	c2 2e       	mov	r12, r18
     f24:	d1 2c       	mov	r13, r1
     f26:	0f b6       	in	r0, 0x3f	; 63
     f28:	f8 94       	cli
     f2a:	0f 92       	push	r0
     f2c:	f8 01       	movw	r30, r16
     f2e:	92 8d       	ldd	r25, Z+26	; 0x1a
     f30:	83 8d       	ldd	r24, Z+27	; 0x1b
     f32:	98 17       	cp	r25, r24
     f34:	18 f0       	brcs	.+6      	; 0xf3c <xQueueGenericSend+0x3c>
     f36:	f2 e0       	ldi	r31, 0x02	; 2
     f38:	cf 12       	cpse	r12, r31
     f3a:	19 c0       	rjmp	.+50     	; 0xf6e <xQueueGenericSend+0x6e>
     f3c:	4c 2d       	mov	r20, r12
     f3e:	b7 01       	movw	r22, r14
     f40:	c8 01       	movw	r24, r16
     f42:	0e 94 50 06 	call	0xca0	; 0xca0 <prvCopyDataToQueue>
     f46:	f8 01       	movw	r30, r16
     f48:	91 89       	ldd	r25, Z+17	; 0x11
     f4a:	99 23       	and	r25, r25
     f4c:	49 f0       	breq	.+18     	; 0xf60 <xQueueGenericSend+0x60>
     f4e:	c8 01       	movw	r24, r16
     f50:	41 96       	adiw	r24, 0x11	; 17
     f52:	0e 94 b2 0c 	call	0x1964	; 0x1964 <xTaskRemoveFromEventList>
     f56:	88 23       	and	r24, r24
     f58:	31 f0       	breq	.+12     	; 0xf66 <xQueueGenericSend+0x66>
     f5a:	0e 94 7d 05 	call	0xafa	; 0xafa <vPortYield>
     f5e:	03 c0       	rjmp	.+6      	; 0xf66 <xQueueGenericSend+0x66>
     f60:	81 11       	cpse	r24, r1
     f62:	0e 94 7d 05 	call	0xafa	; 0xafa <vPortYield>
     f66:	0f 90       	pop	r0
     f68:	0f be       	out	0x3f, r0	; 63
     f6a:	81 e0       	ldi	r24, 0x01	; 1
     f6c:	4d c0       	rjmp	.+154    	; 0x1008 <xQueueGenericSend+0x108>
     f6e:	8c 81       	ldd	r24, Y+4	; 0x04
     f70:	9d 81       	ldd	r25, Y+5	; 0x05
     f72:	89 2b       	or	r24, r25
     f74:	21 f4       	brne	.+8      	; 0xf7e <xQueueGenericSend+0x7e>
     f76:	0f 90       	pop	r0
     f78:	0f be       	out	0x3f, r0	; 63
     f7a:	80 e0       	ldi	r24, 0x00	; 0
     f7c:	45 c0       	rjmp	.+138    	; 0x1008 <xQueueGenericSend+0x108>
     f7e:	d1 10       	cpse	r13, r1
     f80:	06 c0       	rjmp	.+12     	; 0xf8e <xQueueGenericSend+0x8e>
     f82:	ce 01       	movw	r24, r28
     f84:	01 96       	adiw	r24, 0x01	; 1
     f86:	0e 94 fa 0c 	call	0x19f4	; 0x19f4 <vTaskSetTimeOutState>
     f8a:	dd 24       	eor	r13, r13
     f8c:	d3 94       	inc	r13
     f8e:	0f 90       	pop	r0
     f90:	0f be       	out	0x3f, r0	; 63
     f92:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <vTaskSuspendAll>
     f96:	0f b6       	in	r0, 0x3f	; 63
     f98:	f8 94       	cli
     f9a:	0f 92       	push	r0
     f9c:	f8 01       	movw	r30, r16
     f9e:	85 8d       	ldd	r24, Z+29	; 0x1d
     fa0:	8f 3f       	cpi	r24, 0xFF	; 255
     fa2:	09 f4       	brne	.+2      	; 0xfa6 <xQueueGenericSend+0xa6>
     fa4:	15 8e       	std	Z+29, r1	; 0x1d
     fa6:	f8 01       	movw	r30, r16
     fa8:	86 8d       	ldd	r24, Z+30	; 0x1e
     faa:	8f 3f       	cpi	r24, 0xFF	; 255
     fac:	09 f4       	brne	.+2      	; 0xfb0 <xQueueGenericSend+0xb0>
     fae:	16 8e       	std	Z+30, r1	; 0x1e
     fb0:	0f 90       	pop	r0
     fb2:	0f be       	out	0x3f, r0	; 63
     fb4:	be 01       	movw	r22, r28
     fb6:	6c 5f       	subi	r22, 0xFC	; 252
     fb8:	7f 4f       	sbci	r23, 0xFF	; 255
     fba:	ce 01       	movw	r24, r28
     fbc:	01 96       	adiw	r24, 0x01	; 1
     fbe:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <xTaskCheckForTimeOut>
     fc2:	81 11       	cpse	r24, r1
     fc4:	1b c0       	rjmp	.+54     	; 0xffc <xQueueGenericSend+0xfc>
     fc6:	c8 01       	movw	r24, r16
     fc8:	0e 94 42 06 	call	0xc84	; 0xc84 <prvIsQueueFull>
     fcc:	88 23       	and	r24, r24
     fce:	81 f0       	breq	.+32     	; 0xff0 <xQueueGenericSend+0xf0>
     fd0:	6c 81       	ldd	r22, Y+4	; 0x04
     fd2:	7d 81       	ldd	r23, Y+5	; 0x05
     fd4:	c8 01       	movw	r24, r16
     fd6:	08 96       	adiw	r24, 0x08	; 8
     fd8:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vTaskPlaceOnEventList>
     fdc:	c8 01       	movw	r24, r16
     fde:	0e 94 c9 06 	call	0xd92	; 0xd92 <prvUnlockQueue>
     fe2:	0e 94 93 0b 	call	0x1726	; 0x1726 <xTaskResumeAll>
     fe6:	81 11       	cpse	r24, r1
     fe8:	9e cf       	rjmp	.-196    	; 0xf26 <xQueueGenericSend+0x26>
     fea:	0e 94 7d 05 	call	0xafa	; 0xafa <vPortYield>
     fee:	9b cf       	rjmp	.-202    	; 0xf26 <xQueueGenericSend+0x26>
     ff0:	c8 01       	movw	r24, r16
     ff2:	0e 94 c9 06 	call	0xd92	; 0xd92 <prvUnlockQueue>
     ff6:	0e 94 93 0b 	call	0x1726	; 0x1726 <xTaskResumeAll>
     ffa:	95 cf       	rjmp	.-214    	; 0xf26 <xQueueGenericSend+0x26>
     ffc:	c8 01       	movw	r24, r16
     ffe:	0e 94 c9 06 	call	0xd92	; 0xd92 <prvUnlockQueue>
    1002:	0e 94 93 0b 	call	0x1726	; 0x1726 <xTaskResumeAll>
    1006:	80 e0       	ldi	r24, 0x00	; 0
    1008:	0f 90       	pop	r0
    100a:	0f 90       	pop	r0
    100c:	0f 90       	pop	r0
    100e:	0f 90       	pop	r0
    1010:	0f 90       	pop	r0
    1012:	df 91       	pop	r29
    1014:	cf 91       	pop	r28
    1016:	1f 91       	pop	r17
    1018:	0f 91       	pop	r16
    101a:	ff 90       	pop	r15
    101c:	ef 90       	pop	r14
    101e:	df 90       	pop	r13
    1020:	cf 90       	pop	r12
    1022:	08 95       	ret

00001024 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1024:	8f 92       	push	r8
    1026:	9f 92       	push	r9
    1028:	bf 92       	push	r11
    102a:	cf 92       	push	r12
    102c:	df 92       	push	r13
    102e:	ef 92       	push	r14
    1030:	ff 92       	push	r15
    1032:	0f 93       	push	r16
    1034:	1f 93       	push	r17
    1036:	cf 93       	push	r28
    1038:	df 93       	push	r29
    103a:	00 d0       	rcall	.+0      	; 0x103c <xQueueGenericReceive+0x18>
    103c:	00 d0       	rcall	.+0      	; 0x103e <xQueueGenericReceive+0x1a>
    103e:	1f 92       	push	r1
    1040:	cd b7       	in	r28, 0x3d	; 61
    1042:	de b7       	in	r29, 0x3e	; 62
    1044:	8c 01       	movw	r16, r24
    1046:	6b 01       	movw	r12, r22
    1048:	5d 83       	std	Y+5, r21	; 0x05
    104a:	4c 83       	std	Y+4, r20	; 0x04
    104c:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    104e:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1050:	0f b6       	in	r0, 0x3f	; 63
    1052:	f8 94       	cli
    1054:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1056:	f8 01       	movw	r30, r16
    1058:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    105a:	ff 20       	and	r15, r15
    105c:	91 f1       	breq	.+100    	; 0x10c2 <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    105e:	86 80       	ldd	r8, Z+6	; 0x06
    1060:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1062:	b6 01       	movw	r22, r12
    1064:	c8 01       	movw	r24, r16
    1066:	0e 94 af 06 	call	0xd5e	; 0xd5e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    106a:	b1 10       	cpse	r11, r1
    106c:	19 c0       	rjmp	.+50     	; 0x10a0 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    106e:	fa 94       	dec	r15
    1070:	f8 01       	movw	r30, r16
    1072:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1074:	80 81       	ld	r24, Z
    1076:	91 81       	ldd	r25, Z+1	; 0x01
    1078:	89 2b       	or	r24, r25
    107a:	29 f4       	brne	.+10     	; 0x1086 <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    107c:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <pvTaskIncrementMutexHeldCount>
    1080:	f8 01       	movw	r30, r16
    1082:	93 83       	std	Z+3, r25	; 0x03
    1084:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1086:	f8 01       	movw	r30, r16
    1088:	80 85       	ldd	r24, Z+8	; 0x08
    108a:	88 23       	and	r24, r24
    108c:	b1 f0       	breq	.+44     	; 0x10ba <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    108e:	c8 01       	movw	r24, r16
    1090:	08 96       	adiw	r24, 0x08	; 8
    1092:	0e 94 b2 0c 	call	0x1964	; 0x1964 <xTaskRemoveFromEventList>
    1096:	88 23       	and	r24, r24
    1098:	81 f0       	breq	.+32     	; 0x10ba <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
    109a:	0e 94 7d 05 	call	0xafa	; 0xafa <vPortYield>
    109e:	0d c0       	rjmp	.+26     	; 0x10ba <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    10a0:	f8 01       	movw	r30, r16
    10a2:	97 82       	std	Z+7, r9	; 0x07
    10a4:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10a6:	81 89       	ldd	r24, Z+17	; 0x11
    10a8:	88 23       	and	r24, r24
    10aa:	39 f0       	breq	.+14     	; 0x10ba <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10ac:	c8 01       	movw	r24, r16
    10ae:	41 96       	adiw	r24, 0x11	; 17
    10b0:	0e 94 b2 0c 	call	0x1964	; 0x1964 <xTaskRemoveFromEventList>
    10b4:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    10b6:	0e 94 7d 05 	call	0xafa	; 0xafa <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    10ba:	0f 90       	pop	r0
    10bc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    10be:	81 e0       	ldi	r24, 0x01	; 1
    10c0:	61 c0       	rjmp	.+194    	; 0x1184 <xQueueGenericReceive+0x160>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    10c2:	8c 81       	ldd	r24, Y+4	; 0x04
    10c4:	9d 81       	ldd	r25, Y+5	; 0x05
    10c6:	89 2b       	or	r24, r25
    10c8:	21 f4       	brne	.+8      	; 0x10d2 <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    10ca:	0f 90       	pop	r0
    10cc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    10ce:	80 e0       	ldi	r24, 0x00	; 0
    10d0:	59 c0       	rjmp	.+178    	; 0x1184 <xQueueGenericReceive+0x160>
				}
				else if( xEntryTimeSet == pdFALSE )
    10d2:	e1 10       	cpse	r14, r1
    10d4:	06 c0       	rjmp	.+12     	; 0x10e2 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    10d6:	ce 01       	movw	r24, r28
    10d8:	01 96       	adiw	r24, 0x01	; 1
    10da:	0e 94 fa 0c 	call	0x19f4	; 0x19f4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    10de:	ee 24       	eor	r14, r14
    10e0:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    10e2:	0f 90       	pop	r0
    10e4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    10e6:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    10ea:	0f b6       	in	r0, 0x3f	; 63
    10ec:	f8 94       	cli
    10ee:	0f 92       	push	r0
    10f0:	f8 01       	movw	r30, r16
    10f2:	85 8d       	ldd	r24, Z+29	; 0x1d
    10f4:	8f 3f       	cpi	r24, 0xFF	; 255
    10f6:	09 f4       	brne	.+2      	; 0x10fa <xQueueGenericReceive+0xd6>
    10f8:	15 8e       	std	Z+29, r1	; 0x1d
    10fa:	f8 01       	movw	r30, r16
    10fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    10fe:	8f 3f       	cpi	r24, 0xFF	; 255
    1100:	09 f4       	brne	.+2      	; 0x1104 <xQueueGenericReceive+0xe0>
    1102:	16 8e       	std	Z+30, r1	; 0x1e
    1104:	0f 90       	pop	r0
    1106:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1108:	be 01       	movw	r22, r28
    110a:	6c 5f       	subi	r22, 0xFC	; 252
    110c:	7f 4f       	sbci	r23, 0xFF	; 255
    110e:	ce 01       	movw	r24, r28
    1110:	01 96       	adiw	r24, 0x01	; 1
    1112:	0e 94 05 0d 	call	0x1a0a	; 0x1a0a <xTaskCheckForTimeOut>
    1116:	81 11       	cpse	r24, r1
    1118:	29 c0       	rjmp	.+82     	; 0x116c <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    111a:	c8 01       	movw	r24, r16
    111c:	0e 94 35 06 	call	0xc6a	; 0xc6a <prvIsQueueEmpty>
    1120:	88 23       	and	r24, r24
    1122:	f1 f0       	breq	.+60     	; 0x1160 <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1124:	f8 01       	movw	r30, r16
    1126:	80 81       	ld	r24, Z
    1128:	91 81       	ldd	r25, Z+1	; 0x01
    112a:	89 2b       	or	r24, r25
    112c:	49 f4       	brne	.+18     	; 0x1140 <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
    112e:	0f b6       	in	r0, 0x3f	; 63
    1130:	f8 94       	cli
    1132:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1134:	82 81       	ldd	r24, Z+2	; 0x02
    1136:	93 81       	ldd	r25, Z+3	; 0x03
    1138:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    113c:	0f 90       	pop	r0
    113e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1140:	6c 81       	ldd	r22, Y+4	; 0x04
    1142:	7d 81       	ldd	r23, Y+5	; 0x05
    1144:	c8 01       	movw	r24, r16
    1146:	41 96       	adiw	r24, 0x11	; 17
    1148:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    114c:	c8 01       	movw	r24, r16
    114e:	0e 94 c9 06 	call	0xd92	; 0xd92 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1152:	0e 94 93 0b 	call	0x1726	; 0x1726 <xTaskResumeAll>
    1156:	81 11       	cpse	r24, r1
    1158:	7b cf       	rjmp	.-266    	; 0x1050 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    115a:	0e 94 7d 05 	call	0xafa	; 0xafa <vPortYield>
    115e:	78 cf       	rjmp	.-272    	; 0x1050 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1160:	c8 01       	movw	r24, r16
    1162:	0e 94 c9 06 	call	0xd92	; 0xd92 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1166:	0e 94 93 0b 	call	0x1726	; 0x1726 <xTaskResumeAll>
    116a:	72 cf       	rjmp	.-284    	; 0x1050 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    116c:	c8 01       	movw	r24, r16
    116e:	0e 94 c9 06 	call	0xd92	; 0xd92 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1172:	0e 94 93 0b 	call	0x1726	; 0x1726 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1176:	c8 01       	movw	r24, r16
    1178:	0e 94 35 06 	call	0xc6a	; 0xc6a <prvIsQueueEmpty>
    117c:	88 23       	and	r24, r24
    117e:	09 f4       	brne	.+2      	; 0x1182 <xQueueGenericReceive+0x15e>
    1180:	67 cf       	rjmp	.-306    	; 0x1050 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1182:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1184:	0f 90       	pop	r0
    1186:	0f 90       	pop	r0
    1188:	0f 90       	pop	r0
    118a:	0f 90       	pop	r0
    118c:	0f 90       	pop	r0
    118e:	df 91       	pop	r29
    1190:	cf 91       	pop	r28
    1192:	1f 91       	pop	r17
    1194:	0f 91       	pop	r16
    1196:	ff 90       	pop	r15
    1198:	ef 90       	pop	r14
    119a:	df 90       	pop	r13
    119c:	cf 90       	pop	r12
    119e:	bf 90       	pop	r11
    11a0:	9f 90       	pop	r9
    11a2:	8f 90       	pop	r8
    11a4:	08 95       	ret

000011a6 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    11a6:	e0 91 a8 04 	lds	r30, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
    11aa:	f0 91 a9 04 	lds	r31, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
    11ae:	80 81       	ld	r24, Z
    11b0:	81 11       	cpse	r24, r1
    11b2:	07 c0       	rjmp	.+14     	; 0x11c2 <prvResetNextTaskUnblockTime+0x1c>
    11b4:	8f ef       	ldi	r24, 0xFF	; 255
    11b6:	9f ef       	ldi	r25, 0xFF	; 255
    11b8:	90 93 80 04 	sts	0x0480, r25	; 0x800480 <xNextTaskUnblockTime+0x1>
    11bc:	80 93 7f 04 	sts	0x047F, r24	; 0x80047f <xNextTaskUnblockTime>
    11c0:	08 95       	ret
    11c2:	e0 91 a8 04 	lds	r30, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
    11c6:	f0 91 a9 04 	lds	r31, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
    11ca:	05 80       	ldd	r0, Z+5	; 0x05
    11cc:	f6 81       	ldd	r31, Z+6	; 0x06
    11ce:	e0 2d       	mov	r30, r0
    11d0:	06 80       	ldd	r0, Z+6	; 0x06
    11d2:	f7 81       	ldd	r31, Z+7	; 0x07
    11d4:	e0 2d       	mov	r30, r0
    11d6:	82 81       	ldd	r24, Z+2	; 0x02
    11d8:	93 81       	ldd	r25, Z+3	; 0x03
    11da:	90 93 80 04 	sts	0x0480, r25	; 0x800480 <xNextTaskUnblockTime+0x1>
    11de:	80 93 7f 04 	sts	0x047F, r24	; 0x80047f <xNextTaskUnblockTime>
    11e2:	08 95       	ret

000011e4 <prvDeleteTCB>:
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	ec 01       	movw	r28, r24
    11ea:	8f 89       	ldd	r24, Y+23	; 0x17
    11ec:	98 8d       	ldd	r25, Y+24	; 0x18
    11ee:	0e 94 1c 04 	call	0x838	; 0x838 <vPortFree>
    11f2:	ce 01       	movw	r24, r28
    11f4:	0e 94 1c 04 	call	0x838	; 0x838 <vPortFree>
    11f8:	df 91       	pop	r29
    11fa:	cf 91       	pop	r28
    11fc:	08 95       	ret

000011fe <prvInitialiseNewTask>:
    11fe:	6f 92       	push	r6
    1200:	7f 92       	push	r7
    1202:	8f 92       	push	r8
    1204:	9f 92       	push	r9
    1206:	af 92       	push	r10
    1208:	bf 92       	push	r11
    120a:	cf 92       	push	r12
    120c:	df 92       	push	r13
    120e:	ef 92       	push	r14
    1210:	0f 93       	push	r16
    1212:	1f 93       	push	r17
    1214:	cf 93       	push	r28
    1216:	df 93       	push	r29
    1218:	cd b7       	in	r28, 0x3d	; 61
    121a:	de b7       	in	r29, 0x3e	; 62
    121c:	4c 01       	movw	r8, r24
    121e:	f5 01       	movw	r30, r10
    1220:	87 89       	ldd	r24, Z+23	; 0x17
    1222:	90 8d       	ldd	r25, Z+24	; 0x18
    1224:	21 50       	subi	r18, 0x01	; 1
    1226:	31 09       	sbc	r19, r1
    1228:	3c 01       	movw	r6, r24
    122a:	62 0e       	add	r6, r18
    122c:	73 1e       	adc	r7, r19
    122e:	20 e0       	ldi	r18, 0x00	; 0
    1230:	0f c0       	rjmp	.+30     	; 0x1250 <prvInitialiseNewTask+0x52>
    1232:	82 2f       	mov	r24, r18
    1234:	90 e0       	ldi	r25, 0x00	; 0
    1236:	fb 01       	movw	r30, r22
    1238:	e8 0f       	add	r30, r24
    123a:	f9 1f       	adc	r31, r25
    123c:	30 81       	ld	r19, Z
    123e:	d5 01       	movw	r26, r10
    1240:	a8 0f       	add	r26, r24
    1242:	b9 1f       	adc	r27, r25
    1244:	59 96       	adiw	r26, 0x19	; 25
    1246:	3c 93       	st	X, r19
    1248:	80 81       	ld	r24, Z
    124a:	88 23       	and	r24, r24
    124c:	19 f0       	breq	.+6      	; 0x1254 <prvInitialiseNewTask+0x56>
    124e:	2f 5f       	subi	r18, 0xFF	; 255
    1250:	28 30       	cpi	r18, 0x08	; 8
    1252:	78 f3       	brcs	.-34     	; 0x1232 <prvInitialiseNewTask+0x34>
    1254:	f5 01       	movw	r30, r10
    1256:	10 a2       	std	Z+32, r1	; 0x20
    1258:	f4 e0       	ldi	r31, 0x04	; 4
    125a:	fe 15       	cp	r31, r14
    125c:	18 f4       	brcc	.+6      	; 0x1264 <prvInitialiseNewTask+0x66>
    125e:	68 94       	set
    1260:	ee 24       	eor	r14, r14
    1262:	e2 f8       	bld	r14, 2
    1264:	f5 01       	movw	r30, r10
    1266:	e6 8a       	std	Z+22, r14	; 0x16
    1268:	e1 a2       	std	Z+33, r14	; 0x21
    126a:	12 a2       	std	Z+34, r1	; 0x22
    126c:	c5 01       	movw	r24, r10
    126e:	02 96       	adiw	r24, 0x02	; 2
    1270:	0e 94 5d 04 	call	0x8ba	; 0x8ba <vListInitialiseItem>
    1274:	c5 01       	movw	r24, r10
    1276:	0c 96       	adiw	r24, 0x0c	; 12
    1278:	0e 94 5d 04 	call	0x8ba	; 0x8ba <vListInitialiseItem>
    127c:	f5 01       	movw	r30, r10
    127e:	b1 86       	std	Z+9, r11	; 0x09
    1280:	a0 86       	std	Z+8, r10	; 0x08
    1282:	85 e0       	ldi	r24, 0x05	; 5
    1284:	90 e0       	ldi	r25, 0x00	; 0
    1286:	8e 19       	sub	r24, r14
    1288:	91 09       	sbc	r25, r1
    128a:	95 87       	std	Z+13, r25	; 0x0d
    128c:	84 87       	std	Z+12, r24	; 0x0c
    128e:	b3 8a       	std	Z+19, r11	; 0x13
    1290:	a2 8a       	std	Z+18, r10	; 0x12
    1292:	13 a2       	std	Z+35, r1	; 0x23
    1294:	14 a2       	std	Z+36, r1	; 0x24
    1296:	15 a2       	std	Z+37, r1	; 0x25
    1298:	16 a2       	std	Z+38, r1	; 0x26
    129a:	17 a2       	std	Z+39, r1	; 0x27
    129c:	a8 01       	movw	r20, r16
    129e:	b4 01       	movw	r22, r8
    12a0:	c3 01       	movw	r24, r6
    12a2:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <pxPortInitialiseStack>
    12a6:	f5 01       	movw	r30, r10
    12a8:	91 83       	std	Z+1, r25	; 0x01
    12aa:	80 83       	st	Z, r24
    12ac:	c1 14       	cp	r12, r1
    12ae:	d1 04       	cpc	r13, r1
    12b0:	19 f0       	breq	.+6      	; 0x12b8 <prvInitialiseNewTask+0xba>
    12b2:	f6 01       	movw	r30, r12
    12b4:	b1 82       	std	Z+1, r11	; 0x01
    12b6:	a0 82       	st	Z, r10
    12b8:	df 91       	pop	r29
    12ba:	cf 91       	pop	r28
    12bc:	1f 91       	pop	r17
    12be:	0f 91       	pop	r16
    12c0:	ef 90       	pop	r14
    12c2:	df 90       	pop	r13
    12c4:	cf 90       	pop	r12
    12c6:	bf 90       	pop	r11
    12c8:	af 90       	pop	r10
    12ca:	9f 90       	pop	r9
    12cc:	8f 90       	pop	r8
    12ce:	7f 90       	pop	r7
    12d0:	6f 90       	pop	r6
    12d2:	08 95       	ret

000012d4 <prvInitialiseTaskLists>:
    12d4:	cf 93       	push	r28
    12d6:	c0 e0       	ldi	r28, 0x00	; 0
    12d8:	10 c0       	rjmp	.+32     	; 0x12fa <prvInitialiseTaskLists+0x26>
    12da:	8c 2f       	mov	r24, r28
    12dc:	90 e0       	ldi	r25, 0x00	; 0
    12de:	9c 01       	movw	r18, r24
    12e0:	22 0f       	add	r18, r18
    12e2:	33 1f       	adc	r19, r19
    12e4:	22 0f       	add	r18, r18
    12e6:	33 1f       	adc	r19, r19
    12e8:	22 0f       	add	r18, r18
    12ea:	33 1f       	adc	r19, r19
    12ec:	82 0f       	add	r24, r18
    12ee:	93 1f       	adc	r25, r19
    12f0:	84 54       	subi	r24, 0x44	; 68
    12f2:	9b 4f       	sbci	r25, 0xFB	; 251
    12f4:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialise>
    12f8:	cf 5f       	subi	r28, 0xFF	; 255
    12fa:	c5 30       	cpi	r28, 0x05	; 5
    12fc:	70 f3       	brcs	.-36     	; 0x12da <prvInitialiseTaskLists+0x6>
    12fe:	83 eb       	ldi	r24, 0xB3	; 179
    1300:	94 e0       	ldi	r25, 0x04	; 4
    1302:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialise>
    1306:	8a ea       	ldi	r24, 0xAA	; 170
    1308:	94 e0       	ldi	r25, 0x04	; 4
    130a:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialise>
    130e:	8d e9       	ldi	r24, 0x9D	; 157
    1310:	94 e0       	ldi	r25, 0x04	; 4
    1312:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialise>
    1316:	84 e9       	ldi	r24, 0x94	; 148
    1318:	94 e0       	ldi	r25, 0x04	; 4
    131a:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialise>
    131e:	8a e8       	ldi	r24, 0x8A	; 138
    1320:	94 e0       	ldi	r25, 0x04	; 4
    1322:	0e 94 4f 04 	call	0x89e	; 0x89e <vListInitialise>
    1326:	83 eb       	ldi	r24, 0xB3	; 179
    1328:	94 e0       	ldi	r25, 0x04	; 4
    132a:	90 93 a9 04 	sts	0x04A9, r25	; 0x8004a9 <pxDelayedTaskList+0x1>
    132e:	80 93 a8 04 	sts	0x04A8, r24	; 0x8004a8 <pxDelayedTaskList>
    1332:	8a ea       	ldi	r24, 0xAA	; 170
    1334:	94 e0       	ldi	r25, 0x04	; 4
    1336:	90 93 a7 04 	sts	0x04A7, r25	; 0x8004a7 <pxOverflowDelayedTaskList+0x1>
    133a:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <pxOverflowDelayedTaskList>
    133e:	cf 91       	pop	r28
    1340:	08 95       	ret

00001342 <prvAddNewTaskToReadyList>:
    1342:	cf 93       	push	r28
    1344:	df 93       	push	r29
    1346:	ec 01       	movw	r28, r24
    1348:	0f b6       	in	r0, 0x3f	; 63
    134a:	f8 94       	cli
    134c:	0f 92       	push	r0
    134e:	80 91 89 04 	lds	r24, 0x0489	; 0x800489 <uxCurrentNumberOfTasks>
    1352:	8f 5f       	subi	r24, 0xFF	; 255
    1354:	80 93 89 04 	sts	0x0489, r24	; 0x800489 <uxCurrentNumberOfTasks>
    1358:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    135c:	90 91 ea 04 	lds	r25, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    1360:	89 2b       	or	r24, r25
    1362:	59 f4       	brne	.+22     	; 0x137a <prvAddNewTaskToReadyList+0x38>
    1364:	d0 93 ea 04 	sts	0x04EA, r29	; 0x8004ea <pxCurrentTCB+0x1>
    1368:	c0 93 e9 04 	sts	0x04E9, r28	; 0x8004e9 <pxCurrentTCB>
    136c:	80 91 89 04 	lds	r24, 0x0489	; 0x800489 <uxCurrentNumberOfTasks>
    1370:	81 30       	cpi	r24, 0x01	; 1
    1372:	99 f4       	brne	.+38     	; 0x139a <prvAddNewTaskToReadyList+0x58>
    1374:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <prvInitialiseTaskLists>
    1378:	10 c0       	rjmp	.+32     	; 0x139a <prvAddNewTaskToReadyList+0x58>
    137a:	80 91 85 04 	lds	r24, 0x0485	; 0x800485 <xSchedulerRunning>
    137e:	81 11       	cpse	r24, r1
    1380:	0c c0       	rjmp	.+24     	; 0x139a <prvAddNewTaskToReadyList+0x58>
    1382:	e0 91 e9 04 	lds	r30, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    1386:	f0 91 ea 04 	lds	r31, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    138a:	96 89       	ldd	r25, Z+22	; 0x16
    138c:	8e 89       	ldd	r24, Y+22	; 0x16
    138e:	89 17       	cp	r24, r25
    1390:	20 f0       	brcs	.+8      	; 0x139a <prvAddNewTaskToReadyList+0x58>
    1392:	d0 93 ea 04 	sts	0x04EA, r29	; 0x8004ea <pxCurrentTCB+0x1>
    1396:	c0 93 e9 04 	sts	0x04E9, r28	; 0x8004e9 <pxCurrentTCB>
    139a:	80 91 81 04 	lds	r24, 0x0481	; 0x800481 <uxTaskNumber>
    139e:	8f 5f       	subi	r24, 0xFF	; 255
    13a0:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <uxTaskNumber>
    13a4:	8e 89       	ldd	r24, Y+22	; 0x16
    13a6:	90 91 86 04 	lds	r25, 0x0486	; 0x800486 <uxTopReadyPriority>
    13aa:	98 17       	cp	r25, r24
    13ac:	10 f4       	brcc	.+4      	; 0x13b2 <prvAddNewTaskToReadyList+0x70>
    13ae:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <uxTopReadyPriority>
    13b2:	90 e0       	ldi	r25, 0x00	; 0
    13b4:	9c 01       	movw	r18, r24
    13b6:	22 0f       	add	r18, r18
    13b8:	33 1f       	adc	r19, r19
    13ba:	22 0f       	add	r18, r18
    13bc:	33 1f       	adc	r19, r19
    13be:	22 0f       	add	r18, r18
    13c0:	33 1f       	adc	r19, r19
    13c2:	82 0f       	add	r24, r18
    13c4:	93 1f       	adc	r25, r19
    13c6:	be 01       	movw	r22, r28
    13c8:	6e 5f       	subi	r22, 0xFE	; 254
    13ca:	7f 4f       	sbci	r23, 0xFF	; 255
    13cc:	84 54       	subi	r24, 0x44	; 68
    13ce:	9b 4f       	sbci	r25, 0xFB	; 251
    13d0:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vListInsertEnd>
    13d4:	0f 90       	pop	r0
    13d6:	0f be       	out	0x3f, r0	; 63
    13d8:	80 91 85 04 	lds	r24, 0x0485	; 0x800485 <xSchedulerRunning>
    13dc:	88 23       	and	r24, r24
    13de:	51 f0       	breq	.+20     	; 0x13f4 <prvAddNewTaskToReadyList+0xb2>
    13e0:	e0 91 e9 04 	lds	r30, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    13e4:	f0 91 ea 04 	lds	r31, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    13e8:	96 89       	ldd	r25, Z+22	; 0x16
    13ea:	8e 89       	ldd	r24, Y+22	; 0x16
    13ec:	98 17       	cp	r25, r24
    13ee:	10 f4       	brcc	.+4      	; 0x13f4 <prvAddNewTaskToReadyList+0xb2>
    13f0:	0e 94 7d 05 	call	0xafa	; 0xafa <vPortYield>
    13f4:	df 91       	pop	r29
    13f6:	cf 91       	pop	r28
    13f8:	08 95       	ret

000013fa <prvAddCurrentTaskToDelayedList>:
    13fa:	ff 92       	push	r15
    13fc:	0f 93       	push	r16
    13fe:	1f 93       	push	r17
    1400:	cf 93       	push	r28
    1402:	df 93       	push	r29
    1404:	ec 01       	movw	r28, r24
    1406:	f6 2e       	mov	r15, r22
    1408:	00 91 87 04 	lds	r16, 0x0487	; 0x800487 <xTickCount>
    140c:	10 91 88 04 	lds	r17, 0x0488	; 0x800488 <xTickCount+0x1>
    1410:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    1414:	90 91 ea 04 	lds	r25, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    1418:	02 96       	adiw	r24, 0x02	; 2
    141a:	0e 94 b3 04 	call	0x966	; 0x966 <uxListRemove>
    141e:	cf 3f       	cpi	r28, 0xFF	; 255
    1420:	8f ef       	ldi	r24, 0xFF	; 255
    1422:	d8 07       	cpc	r29, r24
    1424:	69 f4       	brne	.+26     	; 0x1440 <prvAddCurrentTaskToDelayedList+0x46>
    1426:	ff 20       	and	r15, r15
    1428:	59 f0       	breq	.+22     	; 0x1440 <prvAddCurrentTaskToDelayedList+0x46>
    142a:	60 91 e9 04 	lds	r22, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    142e:	70 91 ea 04 	lds	r23, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    1432:	6e 5f       	subi	r22, 0xFE	; 254
    1434:	7f 4f       	sbci	r23, 0xFF	; 255
    1436:	8a e8       	ldi	r24, 0x8A	; 138
    1438:	94 e0       	ldi	r25, 0x04	; 4
    143a:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vListInsertEnd>
    143e:	2f c0       	rjmp	.+94     	; 0x149e <prvAddCurrentTaskToDelayedList+0xa4>
    1440:	c0 0f       	add	r28, r16
    1442:	d1 1f       	adc	r29, r17
    1444:	e0 91 e9 04 	lds	r30, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    1448:	f0 91 ea 04 	lds	r31, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    144c:	d3 83       	std	Z+3, r29	; 0x03
    144e:	c2 83       	std	Z+2, r28	; 0x02
    1450:	c0 17       	cp	r28, r16
    1452:	d1 07       	cpc	r29, r17
    1454:	68 f4       	brcc	.+26     	; 0x1470 <prvAddCurrentTaskToDelayedList+0x76>
    1456:	60 91 e9 04 	lds	r22, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    145a:	70 91 ea 04 	lds	r23, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    145e:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <pxOverflowDelayedTaskList>
    1462:	90 91 a7 04 	lds	r25, 0x04A7	; 0x8004a7 <pxOverflowDelayedTaskList+0x1>
    1466:	6e 5f       	subi	r22, 0xFE	; 254
    1468:	7f 4f       	sbci	r23, 0xFF	; 255
    146a:	0e 94 82 04 	call	0x904	; 0x904 <vListInsert>
    146e:	17 c0       	rjmp	.+46     	; 0x149e <prvAddCurrentTaskToDelayedList+0xa4>
    1470:	60 91 e9 04 	lds	r22, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    1474:	70 91 ea 04 	lds	r23, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    1478:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
    147c:	90 91 a9 04 	lds	r25, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
    1480:	6e 5f       	subi	r22, 0xFE	; 254
    1482:	7f 4f       	sbci	r23, 0xFF	; 255
    1484:	0e 94 82 04 	call	0x904	; 0x904 <vListInsert>
    1488:	80 91 7f 04 	lds	r24, 0x047F	; 0x80047f <xNextTaskUnblockTime>
    148c:	90 91 80 04 	lds	r25, 0x0480	; 0x800480 <xNextTaskUnblockTime+0x1>
    1490:	c8 17       	cp	r28, r24
    1492:	d9 07       	cpc	r29, r25
    1494:	20 f4       	brcc	.+8      	; 0x149e <prvAddCurrentTaskToDelayedList+0xa4>
    1496:	d0 93 80 04 	sts	0x0480, r29	; 0x800480 <xNextTaskUnblockTime+0x1>
    149a:	c0 93 7f 04 	sts	0x047F, r28	; 0x80047f <xNextTaskUnblockTime>
    149e:	df 91       	pop	r29
    14a0:	cf 91       	pop	r28
    14a2:	1f 91       	pop	r17
    14a4:	0f 91       	pop	r16
    14a6:	ff 90       	pop	r15
    14a8:	08 95       	ret

000014aa <xTaskCreate>:
    14aa:	2f 92       	push	r2
    14ac:	3f 92       	push	r3
    14ae:	4f 92       	push	r4
    14b0:	5f 92       	push	r5
    14b2:	6f 92       	push	r6
    14b4:	7f 92       	push	r7
    14b6:	8f 92       	push	r8
    14b8:	9f 92       	push	r9
    14ba:	af 92       	push	r10
    14bc:	bf 92       	push	r11
    14be:	cf 92       	push	r12
    14c0:	df 92       	push	r13
    14c2:	ef 92       	push	r14
    14c4:	ff 92       	push	r15
    14c6:	0f 93       	push	r16
    14c8:	1f 93       	push	r17
    14ca:	cf 93       	push	r28
    14cc:	df 93       	push	r29
    14ce:	3c 01       	movw	r6, r24
    14d0:	1b 01       	movw	r2, r22
    14d2:	5a 01       	movw	r10, r20
    14d4:	29 01       	movw	r4, r18
    14d6:	ca 01       	movw	r24, r20
    14d8:	0e 94 a0 03 	call	0x740	; 0x740 <pvPortMalloc>
    14dc:	6c 01       	movw	r12, r24
    14de:	89 2b       	or	r24, r25
    14e0:	71 f0       	breq	.+28     	; 0x14fe <xTaskCreate+0x54>
    14e2:	88 e2       	ldi	r24, 0x28	; 40
    14e4:	90 e0       	ldi	r25, 0x00	; 0
    14e6:	0e 94 a0 03 	call	0x740	; 0x740 <pvPortMalloc>
    14ea:	ec 01       	movw	r28, r24
    14ec:	89 2b       	or	r24, r25
    14ee:	19 f0       	breq	.+6      	; 0x14f6 <xTaskCreate+0x4c>
    14f0:	d8 8e       	std	Y+24, r13	; 0x18
    14f2:	cf 8a       	std	Y+23, r12	; 0x17
    14f4:	06 c0       	rjmp	.+12     	; 0x1502 <xTaskCreate+0x58>
    14f6:	c6 01       	movw	r24, r12
    14f8:	0e 94 1c 04 	call	0x838	; 0x838 <vPortFree>
    14fc:	02 c0       	rjmp	.+4      	; 0x1502 <xTaskCreate+0x58>
    14fe:	c0 e0       	ldi	r28, 0x00	; 0
    1500:	d0 e0       	ldi	r29, 0x00	; 0
    1502:	20 97       	sbiw	r28, 0x00	; 0
    1504:	91 f0       	breq	.+36     	; 0x152a <xTaskCreate+0x80>
    1506:	95 01       	movw	r18, r10
    1508:	40 e0       	ldi	r20, 0x00	; 0
    150a:	50 e0       	ldi	r21, 0x00	; 0
    150c:	81 2c       	mov	r8, r1
    150e:	91 2c       	mov	r9, r1
    1510:	5e 01       	movw	r10, r28
    1512:	67 01       	movw	r12, r14
    1514:	e0 2e       	mov	r14, r16
    1516:	82 01       	movw	r16, r4
    1518:	b1 01       	movw	r22, r2
    151a:	c3 01       	movw	r24, r6
    151c:	0e 94 ff 08 	call	0x11fe	; 0x11fe <prvInitialiseNewTask>
    1520:	ce 01       	movw	r24, r28
    1522:	0e 94 a1 09 	call	0x1342	; 0x1342 <prvAddNewTaskToReadyList>
    1526:	81 e0       	ldi	r24, 0x01	; 1
    1528:	01 c0       	rjmp	.+2      	; 0x152c <xTaskCreate+0x82>
    152a:	8f ef       	ldi	r24, 0xFF	; 255
    152c:	df 91       	pop	r29
    152e:	cf 91       	pop	r28
    1530:	1f 91       	pop	r17
    1532:	0f 91       	pop	r16
    1534:	ff 90       	pop	r15
    1536:	ef 90       	pop	r14
    1538:	df 90       	pop	r13
    153a:	cf 90       	pop	r12
    153c:	bf 90       	pop	r11
    153e:	af 90       	pop	r10
    1540:	9f 90       	pop	r9
    1542:	8f 90       	pop	r8
    1544:	7f 90       	pop	r7
    1546:	6f 90       	pop	r6
    1548:	5f 90       	pop	r5
    154a:	4f 90       	pop	r4
    154c:	3f 90       	pop	r3
    154e:	2f 90       	pop	r2
    1550:	08 95       	ret

00001552 <vTaskStartScheduler>:
    1552:	ef 92       	push	r14
    1554:	ff 92       	push	r15
    1556:	0f 93       	push	r16
    1558:	0f 2e       	mov	r0, r31
    155a:	fd e7       	ldi	r31, 0x7D	; 125
    155c:	ef 2e       	mov	r14, r31
    155e:	f4 e0       	ldi	r31, 0x04	; 4
    1560:	ff 2e       	mov	r15, r31
    1562:	f0 2d       	mov	r31, r0
    1564:	00 e0       	ldi	r16, 0x00	; 0
    1566:	20 e0       	ldi	r18, 0x00	; 0
    1568:	30 e0       	ldi	r19, 0x00	; 0
    156a:	40 e5       	ldi	r20, 0x50	; 80
    156c:	50 e0       	ldi	r21, 0x00	; 0
    156e:	6a e7       	ldi	r22, 0x7A	; 122
    1570:	70 e0       	ldi	r23, 0x00	; 0
    1572:	89 e4       	ldi	r24, 0x49	; 73
    1574:	9c e0       	ldi	r25, 0x0C	; 12
    1576:	0e 94 55 0a 	call	0x14aa	; 0x14aa <xTaskCreate>
    157a:	81 30       	cpi	r24, 0x01	; 1
    157c:	81 f4       	brne	.+32     	; 0x159e <vTaskStartScheduler+0x4c>
    157e:	f8 94       	cli
    1580:	8f ef       	ldi	r24, 0xFF	; 255
    1582:	9f ef       	ldi	r25, 0xFF	; 255
    1584:	90 93 80 04 	sts	0x0480, r25	; 0x800480 <xNextTaskUnblockTime+0x1>
    1588:	80 93 7f 04 	sts	0x047F, r24	; 0x80047f <xNextTaskUnblockTime>
    158c:	81 e0       	ldi	r24, 0x01	; 1
    158e:	80 93 85 04 	sts	0x0485, r24	; 0x800485 <xSchedulerRunning>
    1592:	10 92 88 04 	sts	0x0488, r1	; 0x800488 <xTickCount+0x1>
    1596:	10 92 87 04 	sts	0x0487, r1	; 0x800487 <xTickCount>
    159a:	0e 94 4e 05 	call	0xa9c	; 0xa9c <xPortStartScheduler>
    159e:	0f 91       	pop	r16
    15a0:	ff 90       	pop	r15
    15a2:	ef 90       	pop	r14
    15a4:	08 95       	ret

000015a6 <vTaskSuspendAll>:
    15a6:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <uxSchedulerSuspended>
    15aa:	8f 5f       	subi	r24, 0xFF	; 255
    15ac:	80 93 7c 04 	sts	0x047C, r24	; 0x80047c <uxSchedulerSuspended>
    15b0:	08 95       	ret

000015b2 <xTaskIncrementTick>:
    15b2:	df 92       	push	r13
    15b4:	ef 92       	push	r14
    15b6:	ff 92       	push	r15
    15b8:	0f 93       	push	r16
    15ba:	1f 93       	push	r17
    15bc:	cf 93       	push	r28
    15be:	df 93       	push	r29
    15c0:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <uxSchedulerSuspended>
    15c4:	81 11       	cpse	r24, r1
    15c6:	97 c0       	rjmp	.+302    	; 0x16f6 <xTaskIncrementTick+0x144>
    15c8:	e0 90 87 04 	lds	r14, 0x0487	; 0x800487 <xTickCount>
    15cc:	f0 90 88 04 	lds	r15, 0x0488	; 0x800488 <xTickCount+0x1>
    15d0:	8f ef       	ldi	r24, 0xFF	; 255
    15d2:	e8 1a       	sub	r14, r24
    15d4:	f8 0a       	sbc	r15, r24
    15d6:	f0 92 88 04 	sts	0x0488, r15	; 0x800488 <xTickCount+0x1>
    15da:	e0 92 87 04 	sts	0x0487, r14	; 0x800487 <xTickCount>
    15de:	e1 14       	cp	r14, r1
    15e0:	f1 04       	cpc	r15, r1
    15e2:	b9 f4       	brne	.+46     	; 0x1612 <xTaskIncrementTick+0x60>
    15e4:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
    15e8:	90 91 a9 04 	lds	r25, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
    15ec:	20 91 a6 04 	lds	r18, 0x04A6	; 0x8004a6 <pxOverflowDelayedTaskList>
    15f0:	30 91 a7 04 	lds	r19, 0x04A7	; 0x8004a7 <pxOverflowDelayedTaskList+0x1>
    15f4:	30 93 a9 04 	sts	0x04A9, r19	; 0x8004a9 <pxDelayedTaskList+0x1>
    15f8:	20 93 a8 04 	sts	0x04A8, r18	; 0x8004a8 <pxDelayedTaskList>
    15fc:	90 93 a7 04 	sts	0x04A7, r25	; 0x8004a7 <pxOverflowDelayedTaskList+0x1>
    1600:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <pxOverflowDelayedTaskList>
    1604:	80 91 82 04 	lds	r24, 0x0482	; 0x800482 <xNumOfOverflows>
    1608:	8f 5f       	subi	r24, 0xFF	; 255
    160a:	80 93 82 04 	sts	0x0482, r24	; 0x800482 <xNumOfOverflows>
    160e:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <prvResetNextTaskUnblockTime>
    1612:	80 91 7f 04 	lds	r24, 0x047F	; 0x80047f <xNextTaskUnblockTime>
    1616:	90 91 80 04 	lds	r25, 0x0480	; 0x800480 <xNextTaskUnblockTime+0x1>
    161a:	e8 16       	cp	r14, r24
    161c:	f9 06       	cpc	r15, r25
    161e:	28 f4       	brcc	.+10     	; 0x162a <xTaskIncrementTick+0x78>
    1620:	d1 2c       	mov	r13, r1
    1622:	53 c0       	rjmp	.+166    	; 0x16ca <xTaskIncrementTick+0x118>
    1624:	dd 24       	eor	r13, r13
    1626:	d3 94       	inc	r13
    1628:	01 c0       	rjmp	.+2      	; 0x162c <xTaskIncrementTick+0x7a>
    162a:	d1 2c       	mov	r13, r1
    162c:	e0 91 a8 04 	lds	r30, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
    1630:	f0 91 a9 04 	lds	r31, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
    1634:	80 81       	ld	r24, Z
    1636:	81 11       	cpse	r24, r1
    1638:	07 c0       	rjmp	.+14     	; 0x1648 <xTaskIncrementTick+0x96>
    163a:	8f ef       	ldi	r24, 0xFF	; 255
    163c:	9f ef       	ldi	r25, 0xFF	; 255
    163e:	90 93 80 04 	sts	0x0480, r25	; 0x800480 <xNextTaskUnblockTime+0x1>
    1642:	80 93 7f 04 	sts	0x047F, r24	; 0x80047f <xNextTaskUnblockTime>
    1646:	41 c0       	rjmp	.+130    	; 0x16ca <xTaskIncrementTick+0x118>
    1648:	e0 91 a8 04 	lds	r30, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
    164c:	f0 91 a9 04 	lds	r31, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
    1650:	05 80       	ldd	r0, Z+5	; 0x05
    1652:	f6 81       	ldd	r31, Z+6	; 0x06
    1654:	e0 2d       	mov	r30, r0
    1656:	c6 81       	ldd	r28, Z+6	; 0x06
    1658:	d7 81       	ldd	r29, Z+7	; 0x07
    165a:	8a 81       	ldd	r24, Y+2	; 0x02
    165c:	9b 81       	ldd	r25, Y+3	; 0x03
    165e:	e8 16       	cp	r14, r24
    1660:	f9 06       	cpc	r15, r25
    1662:	28 f4       	brcc	.+10     	; 0x166e <xTaskIncrementTick+0xbc>
    1664:	90 93 80 04 	sts	0x0480, r25	; 0x800480 <xNextTaskUnblockTime+0x1>
    1668:	80 93 7f 04 	sts	0x047F, r24	; 0x80047f <xNextTaskUnblockTime>
    166c:	2e c0       	rjmp	.+92     	; 0x16ca <xTaskIncrementTick+0x118>
    166e:	8e 01       	movw	r16, r28
    1670:	0e 5f       	subi	r16, 0xFE	; 254
    1672:	1f 4f       	sbci	r17, 0xFF	; 255
    1674:	c8 01       	movw	r24, r16
    1676:	0e 94 b3 04 	call	0x966	; 0x966 <uxListRemove>
    167a:	8c 89       	ldd	r24, Y+20	; 0x14
    167c:	9d 89       	ldd	r25, Y+21	; 0x15
    167e:	89 2b       	or	r24, r25
    1680:	21 f0       	breq	.+8      	; 0x168a <xTaskIncrementTick+0xd8>
    1682:	ce 01       	movw	r24, r28
    1684:	0c 96       	adiw	r24, 0x0c	; 12
    1686:	0e 94 b3 04 	call	0x966	; 0x966 <uxListRemove>
    168a:	8e 89       	ldd	r24, Y+22	; 0x16
    168c:	90 91 86 04 	lds	r25, 0x0486	; 0x800486 <uxTopReadyPriority>
    1690:	98 17       	cp	r25, r24
    1692:	10 f4       	brcc	.+4      	; 0x1698 <xTaskIncrementTick+0xe6>
    1694:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <uxTopReadyPriority>
    1698:	90 e0       	ldi	r25, 0x00	; 0
    169a:	9c 01       	movw	r18, r24
    169c:	22 0f       	add	r18, r18
    169e:	33 1f       	adc	r19, r19
    16a0:	22 0f       	add	r18, r18
    16a2:	33 1f       	adc	r19, r19
    16a4:	22 0f       	add	r18, r18
    16a6:	33 1f       	adc	r19, r19
    16a8:	82 0f       	add	r24, r18
    16aa:	93 1f       	adc	r25, r19
    16ac:	b8 01       	movw	r22, r16
    16ae:	84 54       	subi	r24, 0x44	; 68
    16b0:	9b 4f       	sbci	r25, 0xFB	; 251
    16b2:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vListInsertEnd>
    16b6:	9e 89       	ldd	r25, Y+22	; 0x16
    16b8:	e0 91 e9 04 	lds	r30, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    16bc:	f0 91 ea 04 	lds	r31, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    16c0:	86 89       	ldd	r24, Z+22	; 0x16
    16c2:	98 17       	cp	r25, r24
    16c4:	08 f0       	brcs	.+2      	; 0x16c8 <xTaskIncrementTick+0x116>
    16c6:	ae cf       	rjmp	.-164    	; 0x1624 <xTaskIncrementTick+0x72>
    16c8:	b1 cf       	rjmp	.-158    	; 0x162c <xTaskIncrementTick+0x7a>
    16ca:	e0 91 e9 04 	lds	r30, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    16ce:	f0 91 ea 04 	lds	r31, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    16d2:	86 89       	ldd	r24, Z+22	; 0x16
    16d4:	90 e0       	ldi	r25, 0x00	; 0
    16d6:	fc 01       	movw	r30, r24
    16d8:	ee 0f       	add	r30, r30
    16da:	ff 1f       	adc	r31, r31
    16dc:	ee 0f       	add	r30, r30
    16de:	ff 1f       	adc	r31, r31
    16e0:	ee 0f       	add	r30, r30
    16e2:	ff 1f       	adc	r31, r31
    16e4:	8e 0f       	add	r24, r30
    16e6:	9f 1f       	adc	r25, r31
    16e8:	fc 01       	movw	r30, r24
    16ea:	e4 54       	subi	r30, 0x44	; 68
    16ec:	fb 4f       	sbci	r31, 0xFB	; 251
    16ee:	80 81       	ld	r24, Z
    16f0:	82 30       	cpi	r24, 0x02	; 2
    16f2:	40 f4       	brcc	.+16     	; 0x1704 <xTaskIncrementTick+0x152>
    16f4:	09 c0       	rjmp	.+18     	; 0x1708 <xTaskIncrementTick+0x156>
    16f6:	80 91 84 04 	lds	r24, 0x0484	; 0x800484 <uxPendedTicks>
    16fa:	8f 5f       	subi	r24, 0xFF	; 255
    16fc:	80 93 84 04 	sts	0x0484, r24	; 0x800484 <uxPendedTicks>
    1700:	d1 2c       	mov	r13, r1
    1702:	02 c0       	rjmp	.+4      	; 0x1708 <xTaskIncrementTick+0x156>
    1704:	dd 24       	eor	r13, r13
    1706:	d3 94       	inc	r13
    1708:	80 91 83 04 	lds	r24, 0x0483	; 0x800483 <xYieldPending>
    170c:	88 23       	and	r24, r24
    170e:	11 f0       	breq	.+4      	; 0x1714 <xTaskIncrementTick+0x162>
    1710:	dd 24       	eor	r13, r13
    1712:	d3 94       	inc	r13
    1714:	8d 2d       	mov	r24, r13
    1716:	df 91       	pop	r29
    1718:	cf 91       	pop	r28
    171a:	1f 91       	pop	r17
    171c:	0f 91       	pop	r16
    171e:	ff 90       	pop	r15
    1720:	ef 90       	pop	r14
    1722:	df 90       	pop	r13
    1724:	08 95       	ret

00001726 <xTaskResumeAll>:
    1726:	0f 93       	push	r16
    1728:	1f 93       	push	r17
    172a:	cf 93       	push	r28
    172c:	df 93       	push	r29
    172e:	0f b6       	in	r0, 0x3f	; 63
    1730:	f8 94       	cli
    1732:	0f 92       	push	r0
    1734:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <uxSchedulerSuspended>
    1738:	81 50       	subi	r24, 0x01	; 1
    173a:	80 93 7c 04 	sts	0x047C, r24	; 0x80047c <uxSchedulerSuspended>
    173e:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <uxSchedulerSuspended>
    1742:	81 11       	cpse	r24, r1
    1744:	58 c0       	rjmp	.+176    	; 0x17f6 <xTaskResumeAll+0xd0>
    1746:	80 91 89 04 	lds	r24, 0x0489	; 0x800489 <uxCurrentNumberOfTasks>
    174a:	81 11       	cpse	r24, r1
    174c:	33 c0       	rjmp	.+102    	; 0x17b4 <xTaskResumeAll+0x8e>
    174e:	56 c0       	rjmp	.+172    	; 0x17fc <xTaskResumeAll+0xd6>
    1750:	e0 91 a2 04 	lds	r30, 0x04A2	; 0x8004a2 <xPendingReadyList+0x5>
    1754:	f0 91 a3 04 	lds	r31, 0x04A3	; 0x8004a3 <xPendingReadyList+0x6>
    1758:	c6 81       	ldd	r28, Z+6	; 0x06
    175a:	d7 81       	ldd	r29, Z+7	; 0x07
    175c:	ce 01       	movw	r24, r28
    175e:	0c 96       	adiw	r24, 0x0c	; 12
    1760:	0e 94 b3 04 	call	0x966	; 0x966 <uxListRemove>
    1764:	8e 01       	movw	r16, r28
    1766:	0e 5f       	subi	r16, 0xFE	; 254
    1768:	1f 4f       	sbci	r17, 0xFF	; 255
    176a:	c8 01       	movw	r24, r16
    176c:	0e 94 b3 04 	call	0x966	; 0x966 <uxListRemove>
    1770:	8e 89       	ldd	r24, Y+22	; 0x16
    1772:	90 91 86 04 	lds	r25, 0x0486	; 0x800486 <uxTopReadyPriority>
    1776:	98 17       	cp	r25, r24
    1778:	10 f4       	brcc	.+4      	; 0x177e <xTaskResumeAll+0x58>
    177a:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <uxTopReadyPriority>
    177e:	90 e0       	ldi	r25, 0x00	; 0
    1780:	9c 01       	movw	r18, r24
    1782:	22 0f       	add	r18, r18
    1784:	33 1f       	adc	r19, r19
    1786:	22 0f       	add	r18, r18
    1788:	33 1f       	adc	r19, r19
    178a:	22 0f       	add	r18, r18
    178c:	33 1f       	adc	r19, r19
    178e:	82 0f       	add	r24, r18
    1790:	93 1f       	adc	r25, r19
    1792:	b8 01       	movw	r22, r16
    1794:	84 54       	subi	r24, 0x44	; 68
    1796:	9b 4f       	sbci	r25, 0xFB	; 251
    1798:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vListInsertEnd>
    179c:	9e 89       	ldd	r25, Y+22	; 0x16
    179e:	e0 91 e9 04 	lds	r30, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    17a2:	f0 91 ea 04 	lds	r31, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    17a6:	86 89       	ldd	r24, Z+22	; 0x16
    17a8:	98 17       	cp	r25, r24
    17aa:	30 f0       	brcs	.+12     	; 0x17b8 <xTaskResumeAll+0x92>
    17ac:	81 e0       	ldi	r24, 0x01	; 1
    17ae:	80 93 83 04 	sts	0x0483, r24	; 0x800483 <xYieldPending>
    17b2:	02 c0       	rjmp	.+4      	; 0x17b8 <xTaskResumeAll+0x92>
    17b4:	c0 e0       	ldi	r28, 0x00	; 0
    17b6:	d0 e0       	ldi	r29, 0x00	; 0
    17b8:	80 91 9d 04 	lds	r24, 0x049D	; 0x80049d <xPendingReadyList>
    17bc:	81 11       	cpse	r24, r1
    17be:	c8 cf       	rjmp	.-112    	; 0x1750 <xTaskResumeAll+0x2a>
    17c0:	cd 2b       	or	r28, r29
    17c2:	11 f0       	breq	.+4      	; 0x17c8 <xTaskResumeAll+0xa2>
    17c4:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <prvResetNextTaskUnblockTime>
    17c8:	c0 91 84 04 	lds	r28, 0x0484	; 0x800484 <uxPendedTicks>
    17cc:	cc 23       	and	r28, r28
    17ce:	59 f0       	breq	.+22     	; 0x17e6 <xTaskResumeAll+0xc0>
    17d0:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <xTaskIncrementTick>
    17d4:	88 23       	and	r24, r24
    17d6:	19 f0       	breq	.+6      	; 0x17de <xTaskResumeAll+0xb8>
    17d8:	81 e0       	ldi	r24, 0x01	; 1
    17da:	80 93 83 04 	sts	0x0483, r24	; 0x800483 <xYieldPending>
    17de:	c1 50       	subi	r28, 0x01	; 1
    17e0:	b9 f7       	brne	.-18     	; 0x17d0 <xTaskResumeAll+0xaa>
    17e2:	10 92 84 04 	sts	0x0484, r1	; 0x800484 <uxPendedTicks>
    17e6:	80 91 83 04 	lds	r24, 0x0483	; 0x800483 <xYieldPending>
    17ea:	88 23       	and	r24, r24
    17ec:	31 f0       	breq	.+12     	; 0x17fa <xTaskResumeAll+0xd4>
    17ee:	0e 94 7d 05 	call	0xafa	; 0xafa <vPortYield>
    17f2:	81 e0       	ldi	r24, 0x01	; 1
    17f4:	03 c0       	rjmp	.+6      	; 0x17fc <xTaskResumeAll+0xd6>
    17f6:	80 e0       	ldi	r24, 0x00	; 0
    17f8:	01 c0       	rjmp	.+2      	; 0x17fc <xTaskResumeAll+0xd6>
    17fa:	80 e0       	ldi	r24, 0x00	; 0
    17fc:	0f 90       	pop	r0
    17fe:	0f be       	out	0x3f, r0	; 63
    1800:	df 91       	pop	r29
    1802:	cf 91       	pop	r28
    1804:	1f 91       	pop	r17
    1806:	0f 91       	pop	r16
    1808:	08 95       	ret

0000180a <vTaskDelay>:
    180a:	cf 93       	push	r28
    180c:	df 93       	push	r29
    180e:	ec 01       	movw	r28, r24
    1810:	89 2b       	or	r24, r25
    1812:	49 f0       	breq	.+18     	; 0x1826 <vTaskDelay+0x1c>
    1814:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <vTaskSuspendAll>
    1818:	60 e0       	ldi	r22, 0x00	; 0
    181a:	ce 01       	movw	r24, r28
    181c:	0e 94 fd 09 	call	0x13fa	; 0x13fa <prvAddCurrentTaskToDelayedList>
    1820:	0e 94 93 0b 	call	0x1726	; 0x1726 <xTaskResumeAll>
    1824:	01 c0       	rjmp	.+2      	; 0x1828 <vTaskDelay+0x1e>
    1826:	80 e0       	ldi	r24, 0x00	; 0
    1828:	81 11       	cpse	r24, r1
    182a:	02 c0       	rjmp	.+4      	; 0x1830 <vTaskDelay+0x26>
    182c:	0e 94 7d 05 	call	0xafa	; 0xafa <vPortYield>
    1830:	df 91       	pop	r29
    1832:	cf 91       	pop	r28
    1834:	08 95       	ret

00001836 <prvCheckTasksWaitingTermination>:
    1836:	cf 93       	push	r28
    1838:	df 93       	push	r29
    183a:	24 c0       	rjmp	.+72     	; 0x1884 <prvCheckTasksWaitingTermination+0x4e>
    183c:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <vTaskSuspendAll>
    1840:	c0 91 94 04 	lds	r28, 0x0494	; 0x800494 <xTasksWaitingTermination>
    1844:	0e 94 93 0b 	call	0x1726	; 0x1726 <xTaskResumeAll>
    1848:	cc 23       	and	r28, r28
    184a:	e1 f0       	breq	.+56     	; 0x1884 <prvCheckTasksWaitingTermination+0x4e>
    184c:	0f b6       	in	r0, 0x3f	; 63
    184e:	f8 94       	cli
    1850:	0f 92       	push	r0
    1852:	e0 91 99 04 	lds	r30, 0x0499	; 0x800499 <xTasksWaitingTermination+0x5>
    1856:	f0 91 9a 04 	lds	r31, 0x049A	; 0x80049a <xTasksWaitingTermination+0x6>
    185a:	c6 81       	ldd	r28, Z+6	; 0x06
    185c:	d7 81       	ldd	r29, Z+7	; 0x07
    185e:	ce 01       	movw	r24, r28
    1860:	02 96       	adiw	r24, 0x02	; 2
    1862:	0e 94 b3 04 	call	0x966	; 0x966 <uxListRemove>
    1866:	80 91 89 04 	lds	r24, 0x0489	; 0x800489 <uxCurrentNumberOfTasks>
    186a:	81 50       	subi	r24, 0x01	; 1
    186c:	80 93 89 04 	sts	0x0489, r24	; 0x800489 <uxCurrentNumberOfTasks>
    1870:	80 91 93 04 	lds	r24, 0x0493	; 0x800493 <uxDeletedTasksWaitingCleanUp>
    1874:	81 50       	subi	r24, 0x01	; 1
    1876:	80 93 93 04 	sts	0x0493, r24	; 0x800493 <uxDeletedTasksWaitingCleanUp>
    187a:	0f 90       	pop	r0
    187c:	0f be       	out	0x3f, r0	; 63
    187e:	ce 01       	movw	r24, r28
    1880:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <prvDeleteTCB>
    1884:	80 91 93 04 	lds	r24, 0x0493	; 0x800493 <uxDeletedTasksWaitingCleanUp>
    1888:	81 11       	cpse	r24, r1
    188a:	d8 cf       	rjmp	.-80     	; 0x183c <prvCheckTasksWaitingTermination+0x6>
    188c:	df 91       	pop	r29
    188e:	cf 91       	pop	r28
    1890:	08 95       	ret

00001892 <prvIdleTask>:
    1892:	0e 94 1b 0c 	call	0x1836	; 0x1836 <prvCheckTasksWaitingTermination>
    1896:	fd cf       	rjmp	.-6      	; 0x1892 <prvIdleTask>

00001898 <vTaskSwitchContext>:
    1898:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <uxSchedulerSuspended>
    189c:	88 23       	and	r24, r24
    189e:	21 f0       	breq	.+8      	; 0x18a8 <vTaskSwitchContext+0x10>
    18a0:	81 e0       	ldi	r24, 0x01	; 1
    18a2:	80 93 83 04 	sts	0x0483, r24	; 0x800483 <xYieldPending>
    18a6:	08 95       	ret
    18a8:	10 92 83 04 	sts	0x0483, r1	; 0x800483 <xYieldPending>
    18ac:	20 91 86 04 	lds	r18, 0x0486	; 0x800486 <uxTopReadyPriority>
    18b0:	01 c0       	rjmp	.+2      	; 0x18b4 <vTaskSwitchContext+0x1c>
    18b2:	21 50       	subi	r18, 0x01	; 1
    18b4:	82 2f       	mov	r24, r18
    18b6:	90 e0       	ldi	r25, 0x00	; 0
    18b8:	fc 01       	movw	r30, r24
    18ba:	ee 0f       	add	r30, r30
    18bc:	ff 1f       	adc	r31, r31
    18be:	ee 0f       	add	r30, r30
    18c0:	ff 1f       	adc	r31, r31
    18c2:	ee 0f       	add	r30, r30
    18c4:	ff 1f       	adc	r31, r31
    18c6:	e8 0f       	add	r30, r24
    18c8:	f9 1f       	adc	r31, r25
    18ca:	e4 54       	subi	r30, 0x44	; 68
    18cc:	fb 4f       	sbci	r31, 0xFB	; 251
    18ce:	30 81       	ld	r19, Z
    18d0:	33 23       	and	r19, r19
    18d2:	79 f3       	breq	.-34     	; 0x18b2 <vTaskSwitchContext+0x1a>
    18d4:	ac 01       	movw	r20, r24
    18d6:	44 0f       	add	r20, r20
    18d8:	55 1f       	adc	r21, r21
    18da:	44 0f       	add	r20, r20
    18dc:	55 1f       	adc	r21, r21
    18de:	44 0f       	add	r20, r20
    18e0:	55 1f       	adc	r21, r21
    18e2:	48 0f       	add	r20, r24
    18e4:	59 1f       	adc	r21, r25
    18e6:	df 01       	movw	r26, r30
    18e8:	01 80       	ldd	r0, Z+1	; 0x01
    18ea:	f2 81       	ldd	r31, Z+2	; 0x02
    18ec:	e0 2d       	mov	r30, r0
    18ee:	02 80       	ldd	r0, Z+2	; 0x02
    18f0:	f3 81       	ldd	r31, Z+3	; 0x03
    18f2:	e0 2d       	mov	r30, r0
    18f4:	12 96       	adiw	r26, 0x02	; 2
    18f6:	fc 93       	st	X, r31
    18f8:	ee 93       	st	-X, r30
    18fa:	11 97       	sbiw	r26, 0x01	; 1
    18fc:	41 54       	subi	r20, 0x41	; 65
    18fe:	5b 4f       	sbci	r21, 0xFB	; 251
    1900:	e4 17       	cp	r30, r20
    1902:	f5 07       	cpc	r31, r21
    1904:	29 f4       	brne	.+10     	; 0x1910 <vTaskSwitchContext+0x78>
    1906:	42 81       	ldd	r20, Z+2	; 0x02
    1908:	53 81       	ldd	r21, Z+3	; 0x03
    190a:	fd 01       	movw	r30, r26
    190c:	52 83       	std	Z+2, r21	; 0x02
    190e:	41 83       	std	Z+1, r20	; 0x01
    1910:	fc 01       	movw	r30, r24
    1912:	ee 0f       	add	r30, r30
    1914:	ff 1f       	adc	r31, r31
    1916:	ee 0f       	add	r30, r30
    1918:	ff 1f       	adc	r31, r31
    191a:	ee 0f       	add	r30, r30
    191c:	ff 1f       	adc	r31, r31
    191e:	8e 0f       	add	r24, r30
    1920:	9f 1f       	adc	r25, r31
    1922:	fc 01       	movw	r30, r24
    1924:	e4 54       	subi	r30, 0x44	; 68
    1926:	fb 4f       	sbci	r31, 0xFB	; 251
    1928:	01 80       	ldd	r0, Z+1	; 0x01
    192a:	f2 81       	ldd	r31, Z+2	; 0x02
    192c:	e0 2d       	mov	r30, r0
    192e:	86 81       	ldd	r24, Z+6	; 0x06
    1930:	97 81       	ldd	r25, Z+7	; 0x07
    1932:	90 93 ea 04 	sts	0x04EA, r25	; 0x8004ea <pxCurrentTCB+0x1>
    1936:	80 93 e9 04 	sts	0x04E9, r24	; 0x8004e9 <pxCurrentTCB>
    193a:	20 93 86 04 	sts	0x0486, r18	; 0x800486 <uxTopReadyPriority>
    193e:	08 95       	ret

00001940 <vTaskPlaceOnEventList>:
    1940:	cf 93       	push	r28
    1942:	df 93       	push	r29
    1944:	eb 01       	movw	r28, r22
    1946:	60 91 e9 04 	lds	r22, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    194a:	70 91 ea 04 	lds	r23, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    194e:	64 5f       	subi	r22, 0xF4	; 244
    1950:	7f 4f       	sbci	r23, 0xFF	; 255
    1952:	0e 94 82 04 	call	0x904	; 0x904 <vListInsert>
    1956:	61 e0       	ldi	r22, 0x01	; 1
    1958:	ce 01       	movw	r24, r28
    195a:	0e 94 fd 09 	call	0x13fa	; 0x13fa <prvAddCurrentTaskToDelayedList>
    195e:	df 91       	pop	r29
    1960:	cf 91       	pop	r28
    1962:	08 95       	ret

00001964 <xTaskRemoveFromEventList>:
    1964:	0f 93       	push	r16
    1966:	1f 93       	push	r17
    1968:	cf 93       	push	r28
    196a:	df 93       	push	r29
    196c:	dc 01       	movw	r26, r24
    196e:	15 96       	adiw	r26, 0x05	; 5
    1970:	ed 91       	ld	r30, X+
    1972:	fc 91       	ld	r31, X
    1974:	16 97       	sbiw	r26, 0x06	; 6
    1976:	c6 81       	ldd	r28, Z+6	; 0x06
    1978:	d7 81       	ldd	r29, Z+7	; 0x07
    197a:	8e 01       	movw	r16, r28
    197c:	04 5f       	subi	r16, 0xF4	; 244
    197e:	1f 4f       	sbci	r17, 0xFF	; 255
    1980:	c8 01       	movw	r24, r16
    1982:	0e 94 b3 04 	call	0x966	; 0x966 <uxListRemove>
    1986:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <uxSchedulerSuspended>
    198a:	81 11       	cpse	r24, r1
    198c:	1c c0       	rjmp	.+56     	; 0x19c6 <xTaskRemoveFromEventList+0x62>
    198e:	0a 50       	subi	r16, 0x0A	; 10
    1990:	11 09       	sbc	r17, r1
    1992:	c8 01       	movw	r24, r16
    1994:	0e 94 b3 04 	call	0x966	; 0x966 <uxListRemove>
    1998:	8e 89       	ldd	r24, Y+22	; 0x16
    199a:	90 91 86 04 	lds	r25, 0x0486	; 0x800486 <uxTopReadyPriority>
    199e:	98 17       	cp	r25, r24
    19a0:	10 f4       	brcc	.+4      	; 0x19a6 <xTaskRemoveFromEventList+0x42>
    19a2:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <uxTopReadyPriority>
    19a6:	90 e0       	ldi	r25, 0x00	; 0
    19a8:	9c 01       	movw	r18, r24
    19aa:	22 0f       	add	r18, r18
    19ac:	33 1f       	adc	r19, r19
    19ae:	22 0f       	add	r18, r18
    19b0:	33 1f       	adc	r19, r19
    19b2:	22 0f       	add	r18, r18
    19b4:	33 1f       	adc	r19, r19
    19b6:	82 0f       	add	r24, r18
    19b8:	93 1f       	adc	r25, r19
    19ba:	b8 01       	movw	r22, r16
    19bc:	84 54       	subi	r24, 0x44	; 68
    19be:	9b 4f       	sbci	r25, 0xFB	; 251
    19c0:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vListInsertEnd>
    19c4:	05 c0       	rjmp	.+10     	; 0x19d0 <xTaskRemoveFromEventList+0x6c>
    19c6:	b8 01       	movw	r22, r16
    19c8:	8d e9       	ldi	r24, 0x9D	; 157
    19ca:	94 e0       	ldi	r25, 0x04	; 4
    19cc:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vListInsertEnd>
    19d0:	9e 89       	ldd	r25, Y+22	; 0x16
    19d2:	e0 91 e9 04 	lds	r30, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    19d6:	f0 91 ea 04 	lds	r31, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    19da:	86 89       	ldd	r24, Z+22	; 0x16
    19dc:	89 17       	cp	r24, r25
    19de:	20 f4       	brcc	.+8      	; 0x19e8 <xTaskRemoveFromEventList+0x84>
    19e0:	81 e0       	ldi	r24, 0x01	; 1
    19e2:	80 93 83 04 	sts	0x0483, r24	; 0x800483 <xYieldPending>
    19e6:	01 c0       	rjmp	.+2      	; 0x19ea <xTaskRemoveFromEventList+0x86>
    19e8:	80 e0       	ldi	r24, 0x00	; 0
    19ea:	df 91       	pop	r29
    19ec:	cf 91       	pop	r28
    19ee:	1f 91       	pop	r17
    19f0:	0f 91       	pop	r16
    19f2:	08 95       	ret

000019f4 <vTaskSetTimeOutState>:
    19f4:	20 91 82 04 	lds	r18, 0x0482	; 0x800482 <xNumOfOverflows>
    19f8:	fc 01       	movw	r30, r24
    19fa:	20 83       	st	Z, r18
    19fc:	20 91 87 04 	lds	r18, 0x0487	; 0x800487 <xTickCount>
    1a00:	30 91 88 04 	lds	r19, 0x0488	; 0x800488 <xTickCount+0x1>
    1a04:	32 83       	std	Z+2, r19	; 0x02
    1a06:	21 83       	std	Z+1, r18	; 0x01
    1a08:	08 95       	ret

00001a0a <xTaskCheckForTimeOut>:
    1a0a:	0f b6       	in	r0, 0x3f	; 63
    1a0c:	f8 94       	cli
    1a0e:	0f 92       	push	r0
    1a10:	40 91 87 04 	lds	r20, 0x0487	; 0x800487 <xTickCount>
    1a14:	50 91 88 04 	lds	r21, 0x0488	; 0x800488 <xTickCount+0x1>
    1a18:	db 01       	movw	r26, r22
    1a1a:	2d 91       	ld	r18, X+
    1a1c:	3c 91       	ld	r19, X
    1a1e:	2f 3f       	cpi	r18, 0xFF	; 255
    1a20:	bf ef       	ldi	r27, 0xFF	; 255
    1a22:	3b 07       	cpc	r19, r27
    1a24:	19 f1       	breq	.+70     	; 0x1a6c <xTaskCheckForTimeOut+0x62>
    1a26:	dc 01       	movw	r26, r24
    1a28:	fc 91       	ld	r31, X
    1a2a:	e0 91 82 04 	lds	r30, 0x0482	; 0x800482 <xNumOfOverflows>
    1a2e:	fe 17       	cp	r31, r30
    1a30:	39 f0       	breq	.+14     	; 0x1a40 <xTaskCheckForTimeOut+0x36>
    1a32:	11 96       	adiw	r26, 0x01	; 1
    1a34:	ed 91       	ld	r30, X+
    1a36:	fc 91       	ld	r31, X
    1a38:	12 97       	sbiw	r26, 0x02	; 2
    1a3a:	4e 17       	cp	r20, r30
    1a3c:	5f 07       	cpc	r21, r31
    1a3e:	c0 f4       	brcc	.+48     	; 0x1a70 <xTaskCheckForTimeOut+0x66>
    1a40:	dc 01       	movw	r26, r24
    1a42:	11 96       	adiw	r26, 0x01	; 1
    1a44:	ed 91       	ld	r30, X+
    1a46:	fc 91       	ld	r31, X
    1a48:	12 97       	sbiw	r26, 0x02	; 2
    1a4a:	da 01       	movw	r26, r20
    1a4c:	ae 1b       	sub	r26, r30
    1a4e:	bf 0b       	sbc	r27, r31
    1a50:	a2 17       	cp	r26, r18
    1a52:	b3 07       	cpc	r27, r19
    1a54:	78 f4       	brcc	.+30     	; 0x1a74 <xTaskCheckForTimeOut+0x6a>
    1a56:	db 01       	movw	r26, r22
    1a58:	e4 1b       	sub	r30, r20
    1a5a:	f5 0b       	sbc	r31, r21
    1a5c:	2e 0f       	add	r18, r30
    1a5e:	3f 1f       	adc	r19, r31
    1a60:	2d 93       	st	X+, r18
    1a62:	3c 93       	st	X, r19
    1a64:	0e 94 fa 0c 	call	0x19f4	; 0x19f4 <vTaskSetTimeOutState>
    1a68:	80 e0       	ldi	r24, 0x00	; 0
    1a6a:	05 c0       	rjmp	.+10     	; 0x1a76 <xTaskCheckForTimeOut+0x6c>
    1a6c:	80 e0       	ldi	r24, 0x00	; 0
    1a6e:	03 c0       	rjmp	.+6      	; 0x1a76 <xTaskCheckForTimeOut+0x6c>
    1a70:	81 e0       	ldi	r24, 0x01	; 1
    1a72:	01 c0       	rjmp	.+2      	; 0x1a76 <xTaskCheckForTimeOut+0x6c>
    1a74:	81 e0       	ldi	r24, 0x01	; 1
    1a76:	0f 90       	pop	r0
    1a78:	0f be       	out	0x3f, r0	; 63
    1a7a:	08 95       	ret

00001a7c <vTaskMissedYield>:
    1a7c:	81 e0       	ldi	r24, 0x01	; 1
    1a7e:	80 93 83 04 	sts	0x0483, r24	; 0x800483 <xYieldPending>
    1a82:	08 95       	ret

00001a84 <vTaskPriorityInherit>:
    1a84:	0f 93       	push	r16
    1a86:	1f 93       	push	r17
    1a88:	cf 93       	push	r28
    1a8a:	df 93       	push	r29
    1a8c:	fc 01       	movw	r30, r24
    1a8e:	89 2b       	or	r24, r25
    1a90:	09 f4       	brne	.+2      	; 0x1a94 <vTaskPriorityInherit+0x10>
    1a92:	55 c0       	rjmp	.+170    	; 0x1b3e <vTaskPriorityInherit+0xba>
    1a94:	26 89       	ldd	r18, Z+22	; 0x16
    1a96:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    1a9a:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    1a9e:	56 96       	adiw	r26, 0x16	; 22
    1aa0:	8c 91       	ld	r24, X
    1aa2:	28 17       	cp	r18, r24
    1aa4:	08 f0       	brcs	.+2      	; 0x1aa8 <vTaskPriorityInherit+0x24>
    1aa6:	4b c0       	rjmp	.+150    	; 0x1b3e <vTaskPriorityInherit+0xba>
    1aa8:	84 85       	ldd	r24, Z+12	; 0x0c
    1aaa:	95 85       	ldd	r25, Z+13	; 0x0d
    1aac:	99 23       	and	r25, r25
    1aae:	64 f0       	brlt	.+24     	; 0x1ac8 <vTaskPriorityInherit+0x44>
    1ab0:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    1ab4:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    1ab8:	56 96       	adiw	r26, 0x16	; 22
    1aba:	3c 91       	ld	r19, X
    1abc:	85 e0       	ldi	r24, 0x05	; 5
    1abe:	90 e0       	ldi	r25, 0x00	; 0
    1ac0:	83 1b       	sub	r24, r19
    1ac2:	91 09       	sbc	r25, r1
    1ac4:	95 87       	std	Z+13, r25	; 0x0d
    1ac6:	84 87       	std	Z+12, r24	; 0x0c
    1ac8:	82 85       	ldd	r24, Z+10	; 0x0a
    1aca:	93 85       	ldd	r25, Z+11	; 0x0b
    1acc:	30 e0       	ldi	r19, 0x00	; 0
    1ace:	a9 01       	movw	r20, r18
    1ad0:	44 0f       	add	r20, r20
    1ad2:	55 1f       	adc	r21, r21
    1ad4:	44 0f       	add	r20, r20
    1ad6:	55 1f       	adc	r21, r21
    1ad8:	44 0f       	add	r20, r20
    1ada:	55 1f       	adc	r21, r21
    1adc:	24 0f       	add	r18, r20
    1ade:	35 1f       	adc	r19, r21
    1ae0:	24 54       	subi	r18, 0x44	; 68
    1ae2:	3b 4f       	sbci	r19, 0xFB	; 251
    1ae4:	82 17       	cp	r24, r18
    1ae6:	93 07       	cpc	r25, r19
    1ae8:	19 f5       	brne	.+70     	; 0x1b30 <vTaskPriorityInherit+0xac>
    1aea:	8f 01       	movw	r16, r30
    1aec:	ef 01       	movw	r28, r30
    1aee:	22 96       	adiw	r28, 0x02	; 2
    1af0:	ce 01       	movw	r24, r28
    1af2:	0e 94 b3 04 	call	0x966	; 0x966 <uxListRemove>
    1af6:	e0 91 e9 04 	lds	r30, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    1afa:	f0 91 ea 04 	lds	r31, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    1afe:	86 89       	ldd	r24, Z+22	; 0x16
    1b00:	f8 01       	movw	r30, r16
    1b02:	86 8b       	std	Z+22, r24	; 0x16
    1b04:	90 91 86 04 	lds	r25, 0x0486	; 0x800486 <uxTopReadyPriority>
    1b08:	98 17       	cp	r25, r24
    1b0a:	10 f4       	brcc	.+4      	; 0x1b10 <vTaskPriorityInherit+0x8c>
    1b0c:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <uxTopReadyPriority>
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	9c 01       	movw	r18, r24
    1b14:	22 0f       	add	r18, r18
    1b16:	33 1f       	adc	r19, r19
    1b18:	22 0f       	add	r18, r18
    1b1a:	33 1f       	adc	r19, r19
    1b1c:	22 0f       	add	r18, r18
    1b1e:	33 1f       	adc	r19, r19
    1b20:	82 0f       	add	r24, r18
    1b22:	93 1f       	adc	r25, r19
    1b24:	be 01       	movw	r22, r28
    1b26:	84 54       	subi	r24, 0x44	; 68
    1b28:	9b 4f       	sbci	r25, 0xFB	; 251
    1b2a:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vListInsertEnd>
    1b2e:	07 c0       	rjmp	.+14     	; 0x1b3e <vTaskPriorityInherit+0xba>
    1b30:	a0 91 e9 04 	lds	r26, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    1b34:	b0 91 ea 04 	lds	r27, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    1b38:	56 96       	adiw	r26, 0x16	; 22
    1b3a:	8c 91       	ld	r24, X
    1b3c:	86 8b       	std	Z+22, r24	; 0x16
    1b3e:	df 91       	pop	r29
    1b40:	cf 91       	pop	r28
    1b42:	1f 91       	pop	r17
    1b44:	0f 91       	pop	r16
    1b46:	08 95       	ret

00001b48 <xTaskPriorityDisinherit>:
    1b48:	0f 93       	push	r16
    1b4a:	1f 93       	push	r17
    1b4c:	cf 93       	push	r28
    1b4e:	df 93       	push	r29
    1b50:	fc 01       	movw	r30, r24
    1b52:	89 2b       	or	r24, r25
    1b54:	79 f1       	breq	.+94     	; 0x1bb4 <xTaskPriorityDisinherit+0x6c>
    1b56:	82 a1       	ldd	r24, Z+34	; 0x22
    1b58:	81 50       	subi	r24, 0x01	; 1
    1b5a:	82 a3       	std	Z+34, r24	; 0x22
    1b5c:	26 89       	ldd	r18, Z+22	; 0x16
    1b5e:	91 a1       	ldd	r25, Z+33	; 0x21
    1b60:	29 17       	cp	r18, r25
    1b62:	51 f1       	breq	.+84     	; 0x1bb8 <xTaskPriorityDisinherit+0x70>
    1b64:	81 11       	cpse	r24, r1
    1b66:	2a c0       	rjmp	.+84     	; 0x1bbc <xTaskPriorityDisinherit+0x74>
    1b68:	ef 01       	movw	r28, r30
    1b6a:	8f 01       	movw	r16, r30
    1b6c:	0e 5f       	subi	r16, 0xFE	; 254
    1b6e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b70:	c8 01       	movw	r24, r16
    1b72:	0e 94 b3 04 	call	0x966	; 0x966 <uxListRemove>
    1b76:	89 a1       	ldd	r24, Y+33	; 0x21
    1b78:	8e 8b       	std	Y+22, r24	; 0x16
    1b7a:	25 e0       	ldi	r18, 0x05	; 5
    1b7c:	30 e0       	ldi	r19, 0x00	; 0
    1b7e:	28 1b       	sub	r18, r24
    1b80:	31 09       	sbc	r19, r1
    1b82:	3d 87       	std	Y+13, r19	; 0x0d
    1b84:	2c 87       	std	Y+12, r18	; 0x0c
    1b86:	90 91 86 04 	lds	r25, 0x0486	; 0x800486 <uxTopReadyPriority>
    1b8a:	98 17       	cp	r25, r24
    1b8c:	10 f4       	brcc	.+4      	; 0x1b92 <xTaskPriorityDisinherit+0x4a>
    1b8e:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <uxTopReadyPriority>
    1b92:	90 e0       	ldi	r25, 0x00	; 0
    1b94:	9c 01       	movw	r18, r24
    1b96:	22 0f       	add	r18, r18
    1b98:	33 1f       	adc	r19, r19
    1b9a:	22 0f       	add	r18, r18
    1b9c:	33 1f       	adc	r19, r19
    1b9e:	22 0f       	add	r18, r18
    1ba0:	33 1f       	adc	r19, r19
    1ba2:	82 0f       	add	r24, r18
    1ba4:	93 1f       	adc	r25, r19
    1ba6:	b8 01       	movw	r22, r16
    1ba8:	84 54       	subi	r24, 0x44	; 68
    1baa:	9b 4f       	sbci	r25, 0xFB	; 251
    1bac:	0e 94 61 04 	call	0x8c2	; 0x8c2 <vListInsertEnd>
    1bb0:	81 e0       	ldi	r24, 0x01	; 1
    1bb2:	05 c0       	rjmp	.+10     	; 0x1bbe <xTaskPriorityDisinherit+0x76>
    1bb4:	80 e0       	ldi	r24, 0x00	; 0
    1bb6:	03 c0       	rjmp	.+6      	; 0x1bbe <xTaskPriorityDisinherit+0x76>
    1bb8:	80 e0       	ldi	r24, 0x00	; 0
    1bba:	01 c0       	rjmp	.+2      	; 0x1bbe <xTaskPriorityDisinherit+0x76>
    1bbc:	80 e0       	ldi	r24, 0x00	; 0
    1bbe:	df 91       	pop	r29
    1bc0:	cf 91       	pop	r28
    1bc2:	1f 91       	pop	r17
    1bc4:	0f 91       	pop	r16
    1bc6:	08 95       	ret

00001bc8 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1bc8:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    1bcc:	90 91 ea 04 	lds	r25, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    1bd0:	89 2b       	or	r24, r25
    1bd2:	39 f0       	breq	.+14     	; 0x1be2 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1bd4:	e0 91 e9 04 	lds	r30, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    1bd8:	f0 91 ea 04 	lds	r31, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
    1bdc:	82 a1       	ldd	r24, Z+34	; 0x22
    1bde:	8f 5f       	subi	r24, 0xFF	; 255
    1be0:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1be2:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <pxCurrentTCB>
    1be6:	90 91 ea 04 	lds	r25, 0x04EA	; 0x8004ea <pxCurrentTCB+0x1>
	}
    1bea:	08 95       	ret

00001bec <EEPROM_voidSendDataToEEPROM>:
    1bec:	1f 93       	push	r17
    1bee:	cf 93       	push	r28
    1bf0:	df 93       	push	r29
    1bf2:	d8 2f       	mov	r29, r24
    1bf4:	c6 2f       	mov	r28, r22
    1bf6:	19 2f       	mov	r17, r25
    1bf8:	10 65       	ori	r17, 0x50	; 80
    1bfa:	0e 94 1a 11 	call	0x2234	; 0x2234 <TWI_TWI_statusStartCondition>
    1bfe:	81 2f       	mov	r24, r17
    1c00:	0e 94 3c 11 	call	0x2278	; 0x2278 <TWI_TWI_statusSendSlaveAdressWithWrite>
    1c04:	8d 2f       	mov	r24, r29
    1c06:	0e 94 68 11 	call	0x22d0	; 0x22d0 <TWI_TWI_statusMasterSendData>
    1c0a:	8c 2f       	mov	r24, r28
    1c0c:	0e 94 68 11 	call	0x22d0	; 0x22d0 <TWI_TWI_statusMasterSendData>
    1c10:	0e 94 88 11 	call	0x2310	; 0x2310 <TWI_voidStopCondition>
    1c14:	8f e1       	ldi	r24, 0x1F	; 31
    1c16:	9e e4       	ldi	r25, 0x4E	; 78
    1c18:	01 97       	sbiw	r24, 0x01	; 1
    1c1a:	f1 f7       	brne	.-4      	; 0x1c18 <EEPROM_voidSendDataToEEPROM+0x2c>
    1c1c:	00 c0       	rjmp	.+0      	; 0x1c1e <EEPROM_voidSendDataToEEPROM+0x32>
    1c1e:	00 00       	nop
    1c20:	df 91       	pop	r29
    1c22:	cf 91       	pop	r28
    1c24:	1f 91       	pop	r17
    1c26:	08 95       	ret

00001c28 <EEPROM_voidRecieveDataFromEEPROM>:
    1c28:	0f 93       	push	r16
    1c2a:	1f 93       	push	r17
    1c2c:	cf 93       	push	r28
    1c2e:	df 93       	push	r29
    1c30:	1f 92       	push	r1
    1c32:	cd b7       	in	r28, 0x3d	; 61
    1c34:	de b7       	in	r29, 0x3e	; 62
    1c36:	08 2f       	mov	r16, r24
    1c38:	19 2f       	mov	r17, r25
    1c3a:	10 65       	ori	r17, 0x50	; 80
    1c3c:	0e 94 1a 11 	call	0x2234	; 0x2234 <TWI_TWI_statusStartCondition>
    1c40:	81 2f       	mov	r24, r17
    1c42:	0e 94 3c 11 	call	0x2278	; 0x2278 <TWI_TWI_statusSendSlaveAdressWithWrite>
    1c46:	80 2f       	mov	r24, r16
    1c48:	0e 94 68 11 	call	0x22d0	; 0x22d0 <TWI_TWI_statusMasterSendData>
    1c4c:	0e 94 2b 11 	call	0x2256	; 0x2256 <TWI_TWI_statusRepeatedStart>
    1c50:	81 2f       	mov	r24, r17
    1c52:	0e 94 52 11 	call	0x22a4	; 0x22a4 <TWI_TWI_statusSendSlaveAdressWithRead>
    1c56:	ce 01       	movw	r24, r28
    1c58:	01 96       	adiw	r24, 0x01	; 1
    1c5a:	0e 94 77 11 	call	0x22ee	; 0x22ee <TWI_TWI_statusMasterReciveData>
    1c5e:	0e 94 88 11 	call	0x2310	; 0x2310 <TWI_voidStopCondition>
    1c62:	8f e1       	ldi	r24, 0x1F	; 31
    1c64:	9e e4       	ldi	r25, 0x4E	; 78
    1c66:	01 97       	sbiw	r24, 0x01	; 1
    1c68:	f1 f7       	brne	.-4      	; 0x1c66 <EEPROM_voidRecieveDataFromEEPROM+0x3e>
    1c6a:	00 c0       	rjmp	.+0      	; 0x1c6c <EEPROM_voidRecieveDataFromEEPROM+0x44>
    1c6c:	00 00       	nop
    1c6e:	89 81       	ldd	r24, Y+1	; 0x01
    1c70:	0f 90       	pop	r0
    1c72:	df 91       	pop	r29
    1c74:	cf 91       	pop	r28
    1c76:	1f 91       	pop	r17
    1c78:	0f 91       	pop	r16
    1c7a:	08 95       	ret

00001c7c <SSD_voidDisplayNum>:
    1c7c:	cf 93       	push	r28
    1c7e:	c8 2f       	mov	r28, r24
    1c80:	60 ef       	ldi	r22, 0xF0	; 240
    1c82:	80 e0       	ldi	r24, 0x00	; 0
    1c84:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <DIO_voidSetPortDir>
    1c88:	6c 2f       	mov	r22, r28
    1c8a:	62 95       	swap	r22
    1c8c:	60 7f       	andi	r22, 0xF0	; 240
    1c8e:	80 e0       	ldi	r24, 0x00	; 0
    1c90:	0e 94 91 0f 	call	0x1f22	; 0x1f22 <DIO_voidSetPortVal>
    1c94:	cf 91       	pop	r28
    1c96:	08 95       	ret

00001c98 <ADC_voidInit>:
void ADC_voidInit(){
	
	/*Reference Selections for ADC : AVCC with external capacitor at AREF pin*/
	 CLR_BIT(ADMUX_REG,7) ; 
	 SET_BIT(ADMUX_REG,6) ; 
	 
    1c98:	87 b1       	in	r24, 0x07	; 7
    1c9a:	8f 77       	andi	r24, 0x7F	; 127
    1c9c:	87 b9       	out	0x07, r24	; 7
	/*select prescaler */
    1c9e:	87 b1       	in	r24, 0x07	; 7
    1ca0:	80 64       	ori	r24, 0x40	; 64
    1ca2:	87 b9       	out	0x07, r24	; 7
	 
	 ADCSRA_REG&=0b11111000 ; 
	 ADCSRA_REG|=ADC_PRESCALER ; 
	
    1ca4:	86 b1       	in	r24, 0x06	; 6
    1ca6:	88 7f       	andi	r24, 0xF8	; 248
    1ca8:	86 b9       	out	0x06, r24	; 6
	
    1caa:	86 b1       	in	r24, 0x06	; 6
    1cac:	87 60       	ori	r24, 0x07	; 7
    1cae:	86 b9       	out	0x06, r24	; 6
	/* ENABLE ADC */
	
	SET_BIT(ADCSRA_REG,7) ; 
	
	//enable adc interrupt
    1cb0:	86 b1       	in	r24, 0x06	; 6
    1cb2:	80 68       	ori	r24, 0x80	; 128
    1cb4:	86 b9       	out	0x06, r24	; 6
    1cb6:	08 95       	ret

00001cb8 <ADC_u16ReadChannel>:
	
}

u16 ADC_u16ReadChannelSyn(u8 copy_u8channel){
	
	  /* select channel */
    1cb8:	97 b1       	in	r25, 0x07	; 7
    1cba:	90 7e       	andi	r25, 0xE0	; 224
    1cbc:	97 b9       	out	0x07, r25	; 7
	  ADMUX_REG &=0b11100000 ; 
    1cbe:	97 b1       	in	r25, 0x07	; 7
    1cc0:	89 2b       	or	r24, r25
    1cc2:	87 b9       	out	0x07, r24	; 7
	  ADMUX_REG |=copy_u8channel ; 
	  /* start conversion */
    1cc4:	86 b1       	in	r24, 0x06	; 6
    1cc6:	80 64       	ori	r24, 0x40	; 64
    1cc8:	86 b9       	out	0x06, r24	; 6
	  SET_BIT(ADCSRA_REG,6) ; 
	  
    1cca:	34 9b       	sbis	0x06, 4	; 6
    1ccc:	fe cf       	rjmp	.-4      	; 0x1cca <ADC_u16ReadChannel+0x12>
	  while(GET_BIT(ADCSRA_REG,4)==0) ; 
	  
    1cce:	86 b1       	in	r24, 0x06	; 6
    1cd0:	80 61       	ori	r24, 0x10	; 16
    1cd2:	86 b9       	out	0x06, r24	; 6
	  SET_BIT(ADCSRA_REG,4) ; // CLR FLAG 
	  
    1cd4:	84 b1       	in	r24, 0x04	; 4
    1cd6:	95 b1       	in	r25, 0x05	; 5
	  return  ADC_REG ; 

    1cd8:	08 95       	ret

00001cda <DIO_voidSetPinDir>:
	     switch(copy_u8port){
			 
			  case DIO_PORTA: TOGGLE_BIT(PORTA_REG,copy_u8pin) ; break;
			  case DIO_PORTB: TOGGLE_BIT(PORTB_REG,copy_u8pin) ; break;
			  case DIO_PORTC: TOGGLE_BIT(PORTC_REG,copy_u8pin) ; break;
			  case DIO_PORTD: TOGGLE_BIT(PORTD_REG,copy_u8pin) ; break ;
    1cda:	42 30       	cpi	r20, 0x02	; 2
    1cdc:	08 f0       	brcs	.+2      	; 0x1ce0 <DIO_voidSetPinDir+0x6>
    1cde:	6f c0       	rjmp	.+222    	; 0x1dbe <DIO_voidSetPinDir+0xe4>
    1ce0:	41 30       	cpi	r20, 0x01	; 1
    1ce2:	a1 f5       	brne	.+104    	; 0x1d4c <DIO_voidSetPinDir+0x72>
    1ce4:	81 30       	cpi	r24, 0x01	; 1
    1ce6:	89 f0       	breq	.+34     	; 0x1d0a <DIO_voidSetPinDir+0x30>
    1ce8:	28 f0       	brcs	.+10     	; 0x1cf4 <DIO_voidSetPinDir+0x1a>
    1cea:	82 30       	cpi	r24, 0x02	; 2
    1cec:	c9 f0       	breq	.+50     	; 0x1d20 <DIO_voidSetPinDir+0x46>
    1cee:	83 30       	cpi	r24, 0x03	; 3
    1cf0:	11 f1       	breq	.+68     	; 0x1d36 <DIO_voidSetPinDir+0x5c>
    1cf2:	08 95       	ret
    1cf4:	2a b3       	in	r18, 0x1a	; 26
    1cf6:	81 e0       	ldi	r24, 0x01	; 1
    1cf8:	90 e0       	ldi	r25, 0x00	; 0
    1cfa:	02 c0       	rjmp	.+4      	; 0x1d00 <DIO_voidSetPinDir+0x26>
    1cfc:	88 0f       	add	r24, r24
    1cfe:	99 1f       	adc	r25, r25
    1d00:	6a 95       	dec	r22
    1d02:	e2 f7       	brpl	.-8      	; 0x1cfc <DIO_voidSetPinDir+0x22>
    1d04:	82 2b       	or	r24, r18
    1d06:	8a bb       	out	0x1a, r24	; 26
    1d08:	08 95       	ret
    1d0a:	27 b3       	in	r18, 0x17	; 23
    1d0c:	81 e0       	ldi	r24, 0x01	; 1
    1d0e:	90 e0       	ldi	r25, 0x00	; 0
    1d10:	02 c0       	rjmp	.+4      	; 0x1d16 <DIO_voidSetPinDir+0x3c>
    1d12:	88 0f       	add	r24, r24
    1d14:	99 1f       	adc	r25, r25
    1d16:	6a 95       	dec	r22
    1d18:	e2 f7       	brpl	.-8      	; 0x1d12 <DIO_voidSetPinDir+0x38>
    1d1a:	82 2b       	or	r24, r18
    1d1c:	87 bb       	out	0x17, r24	; 23
    1d1e:	08 95       	ret
    1d20:	24 b3       	in	r18, 0x14	; 20
    1d22:	81 e0       	ldi	r24, 0x01	; 1
    1d24:	90 e0       	ldi	r25, 0x00	; 0
    1d26:	02 c0       	rjmp	.+4      	; 0x1d2c <DIO_voidSetPinDir+0x52>
    1d28:	88 0f       	add	r24, r24
    1d2a:	99 1f       	adc	r25, r25
    1d2c:	6a 95       	dec	r22
    1d2e:	e2 f7       	brpl	.-8      	; 0x1d28 <DIO_voidSetPinDir+0x4e>
    1d30:	82 2b       	or	r24, r18
    1d32:	84 bb       	out	0x14, r24	; 20
    1d34:	08 95       	ret
    1d36:	21 b3       	in	r18, 0x11	; 17
    1d38:	81 e0       	ldi	r24, 0x01	; 1
    1d3a:	90 e0       	ldi	r25, 0x00	; 0
    1d3c:	02 c0       	rjmp	.+4      	; 0x1d42 <DIO_voidSetPinDir+0x68>
    1d3e:	88 0f       	add	r24, r24
    1d40:	99 1f       	adc	r25, r25
    1d42:	6a 95       	dec	r22
    1d44:	e2 f7       	brpl	.-8      	; 0x1d3e <DIO_voidSetPinDir+0x64>
    1d46:	82 2b       	or	r24, r18
    1d48:	81 bb       	out	0x11, r24	; 17
    1d4a:	08 95       	ret
    1d4c:	41 11       	cpse	r20, r1
    1d4e:	37 c0       	rjmp	.+110    	; 0x1dbe <DIO_voidSetPinDir+0xe4>
    1d50:	81 30       	cpi	r24, 0x01	; 1
    1d52:	91 f0       	breq	.+36     	; 0x1d78 <DIO_voidSetPinDir+0x9e>
    1d54:	28 f0       	brcs	.+10     	; 0x1d60 <DIO_voidSetPinDir+0x86>
    1d56:	82 30       	cpi	r24, 0x02	; 2
    1d58:	d9 f0       	breq	.+54     	; 0x1d90 <DIO_voidSetPinDir+0xb6>
    1d5a:	83 30       	cpi	r24, 0x03	; 3
    1d5c:	29 f1       	breq	.+74     	; 0x1da8 <DIO_voidSetPinDir+0xce>
    1d5e:	08 95       	ret
    1d60:	2a b3       	in	r18, 0x1a	; 26
    1d62:	81 e0       	ldi	r24, 0x01	; 1
    1d64:	90 e0       	ldi	r25, 0x00	; 0
    1d66:	02 c0       	rjmp	.+4      	; 0x1d6c <DIO_voidSetPinDir+0x92>
    1d68:	88 0f       	add	r24, r24
    1d6a:	99 1f       	adc	r25, r25
    1d6c:	6a 95       	dec	r22
    1d6e:	e2 f7       	brpl	.-8      	; 0x1d68 <DIO_voidSetPinDir+0x8e>
    1d70:	80 95       	com	r24
    1d72:	82 23       	and	r24, r18
    1d74:	8a bb       	out	0x1a, r24	; 26
    1d76:	08 95       	ret
    1d78:	27 b3       	in	r18, 0x17	; 23
    1d7a:	81 e0       	ldi	r24, 0x01	; 1
    1d7c:	90 e0       	ldi	r25, 0x00	; 0
    1d7e:	02 c0       	rjmp	.+4      	; 0x1d84 <DIO_voidSetPinDir+0xaa>
    1d80:	88 0f       	add	r24, r24
    1d82:	99 1f       	adc	r25, r25
    1d84:	6a 95       	dec	r22
    1d86:	e2 f7       	brpl	.-8      	; 0x1d80 <DIO_voidSetPinDir+0xa6>
    1d88:	80 95       	com	r24
    1d8a:	82 23       	and	r24, r18
    1d8c:	87 bb       	out	0x17, r24	; 23
    1d8e:	08 95       	ret
    1d90:	24 b3       	in	r18, 0x14	; 20
    1d92:	81 e0       	ldi	r24, 0x01	; 1
    1d94:	90 e0       	ldi	r25, 0x00	; 0
    1d96:	02 c0       	rjmp	.+4      	; 0x1d9c <DIO_voidSetPinDir+0xc2>
    1d98:	88 0f       	add	r24, r24
    1d9a:	99 1f       	adc	r25, r25
    1d9c:	6a 95       	dec	r22
    1d9e:	e2 f7       	brpl	.-8      	; 0x1d98 <DIO_voidSetPinDir+0xbe>
    1da0:	80 95       	com	r24
    1da2:	82 23       	and	r24, r18
    1da4:	84 bb       	out	0x14, r24	; 20
    1da6:	08 95       	ret
    1da8:	21 b3       	in	r18, 0x11	; 17
    1daa:	81 e0       	ldi	r24, 0x01	; 1
    1dac:	90 e0       	ldi	r25, 0x00	; 0
    1dae:	02 c0       	rjmp	.+4      	; 0x1db4 <DIO_voidSetPinDir+0xda>
    1db0:	88 0f       	add	r24, r24
    1db2:	99 1f       	adc	r25, r25
    1db4:	6a 95       	dec	r22
    1db6:	e2 f7       	brpl	.-8      	; 0x1db0 <DIO_voidSetPinDir+0xd6>
    1db8:	80 95       	com	r24
    1dba:	82 23       	and	r24, r18
    1dbc:	81 bb       	out	0x11, r24	; 17
    1dbe:	08 95       	ret

00001dc0 <DIO_voidSetPinVal>:
    1dc0:	42 30       	cpi	r20, 0x02	; 2
    1dc2:	08 f0       	brcs	.+2      	; 0x1dc6 <DIO_voidSetPinVal+0x6>
    1dc4:	6f c0       	rjmp	.+222    	; 0x1ea4 <DIO_voidSetPinVal+0xe4>
    1dc6:	41 30       	cpi	r20, 0x01	; 1
    1dc8:	a1 f5       	brne	.+104    	; 0x1e32 <DIO_voidSetPinVal+0x72>
    1dca:	81 30       	cpi	r24, 0x01	; 1
    1dcc:	89 f0       	breq	.+34     	; 0x1df0 <DIO_voidSetPinVal+0x30>
    1dce:	28 f0       	brcs	.+10     	; 0x1dda <DIO_voidSetPinVal+0x1a>
    1dd0:	82 30       	cpi	r24, 0x02	; 2
    1dd2:	c9 f0       	breq	.+50     	; 0x1e06 <DIO_voidSetPinVal+0x46>
    1dd4:	83 30       	cpi	r24, 0x03	; 3
    1dd6:	11 f1       	breq	.+68     	; 0x1e1c <DIO_voidSetPinVal+0x5c>
    1dd8:	08 95       	ret
    1dda:	2b b3       	in	r18, 0x1b	; 27
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	90 e0       	ldi	r25, 0x00	; 0
    1de0:	02 c0       	rjmp	.+4      	; 0x1de6 <DIO_voidSetPinVal+0x26>
    1de2:	88 0f       	add	r24, r24
    1de4:	99 1f       	adc	r25, r25
    1de6:	6a 95       	dec	r22
    1de8:	e2 f7       	brpl	.-8      	; 0x1de2 <DIO_voidSetPinVal+0x22>
    1dea:	82 2b       	or	r24, r18
    1dec:	8b bb       	out	0x1b, r24	; 27
    1dee:	08 95       	ret
    1df0:	28 b3       	in	r18, 0x18	; 24
    1df2:	81 e0       	ldi	r24, 0x01	; 1
    1df4:	90 e0       	ldi	r25, 0x00	; 0
    1df6:	02 c0       	rjmp	.+4      	; 0x1dfc <DIO_voidSetPinVal+0x3c>
    1df8:	88 0f       	add	r24, r24
    1dfa:	99 1f       	adc	r25, r25
    1dfc:	6a 95       	dec	r22
    1dfe:	e2 f7       	brpl	.-8      	; 0x1df8 <DIO_voidSetPinVal+0x38>
    1e00:	82 2b       	or	r24, r18
    1e02:	88 bb       	out	0x18, r24	; 24
    1e04:	08 95       	ret
    1e06:	25 b3       	in	r18, 0x15	; 21
    1e08:	81 e0       	ldi	r24, 0x01	; 1
    1e0a:	90 e0       	ldi	r25, 0x00	; 0
    1e0c:	02 c0       	rjmp	.+4      	; 0x1e12 <DIO_voidSetPinVal+0x52>
    1e0e:	88 0f       	add	r24, r24
    1e10:	99 1f       	adc	r25, r25
    1e12:	6a 95       	dec	r22
    1e14:	e2 f7       	brpl	.-8      	; 0x1e0e <DIO_voidSetPinVal+0x4e>
    1e16:	82 2b       	or	r24, r18
    1e18:	85 bb       	out	0x15, r24	; 21
    1e1a:	08 95       	ret
    1e1c:	22 b3       	in	r18, 0x12	; 18
    1e1e:	81 e0       	ldi	r24, 0x01	; 1
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	02 c0       	rjmp	.+4      	; 0x1e28 <DIO_voidSetPinVal+0x68>
    1e24:	88 0f       	add	r24, r24
    1e26:	99 1f       	adc	r25, r25
    1e28:	6a 95       	dec	r22
    1e2a:	e2 f7       	brpl	.-8      	; 0x1e24 <DIO_voidSetPinVal+0x64>
    1e2c:	82 2b       	or	r24, r18
    1e2e:	82 bb       	out	0x12, r24	; 18
    1e30:	08 95       	ret
    1e32:	41 11       	cpse	r20, r1
    1e34:	37 c0       	rjmp	.+110    	; 0x1ea4 <DIO_voidSetPinVal+0xe4>
    1e36:	81 30       	cpi	r24, 0x01	; 1
    1e38:	91 f0       	breq	.+36     	; 0x1e5e <DIO_voidSetPinVal+0x9e>
    1e3a:	28 f0       	brcs	.+10     	; 0x1e46 <DIO_voidSetPinVal+0x86>
    1e3c:	82 30       	cpi	r24, 0x02	; 2
    1e3e:	d9 f0       	breq	.+54     	; 0x1e76 <DIO_voidSetPinVal+0xb6>
    1e40:	83 30       	cpi	r24, 0x03	; 3
    1e42:	29 f1       	breq	.+74     	; 0x1e8e <DIO_voidSetPinVal+0xce>
    1e44:	08 95       	ret
    1e46:	2b b3       	in	r18, 0x1b	; 27
    1e48:	81 e0       	ldi	r24, 0x01	; 1
    1e4a:	90 e0       	ldi	r25, 0x00	; 0
    1e4c:	02 c0       	rjmp	.+4      	; 0x1e52 <DIO_voidSetPinVal+0x92>
    1e4e:	88 0f       	add	r24, r24
    1e50:	99 1f       	adc	r25, r25
    1e52:	6a 95       	dec	r22
    1e54:	e2 f7       	brpl	.-8      	; 0x1e4e <DIO_voidSetPinVal+0x8e>
    1e56:	80 95       	com	r24
    1e58:	82 23       	and	r24, r18
    1e5a:	8b bb       	out	0x1b, r24	; 27
    1e5c:	08 95       	ret
    1e5e:	28 b3       	in	r18, 0x18	; 24
    1e60:	81 e0       	ldi	r24, 0x01	; 1
    1e62:	90 e0       	ldi	r25, 0x00	; 0
    1e64:	02 c0       	rjmp	.+4      	; 0x1e6a <DIO_voidSetPinVal+0xaa>
    1e66:	88 0f       	add	r24, r24
    1e68:	99 1f       	adc	r25, r25
    1e6a:	6a 95       	dec	r22
    1e6c:	e2 f7       	brpl	.-8      	; 0x1e66 <DIO_voidSetPinVal+0xa6>
    1e6e:	80 95       	com	r24
    1e70:	82 23       	and	r24, r18
    1e72:	88 bb       	out	0x18, r24	; 24
    1e74:	08 95       	ret
    1e76:	25 b3       	in	r18, 0x15	; 21
    1e78:	81 e0       	ldi	r24, 0x01	; 1
    1e7a:	90 e0       	ldi	r25, 0x00	; 0
    1e7c:	02 c0       	rjmp	.+4      	; 0x1e82 <DIO_voidSetPinVal+0xc2>
    1e7e:	88 0f       	add	r24, r24
    1e80:	99 1f       	adc	r25, r25
    1e82:	6a 95       	dec	r22
    1e84:	e2 f7       	brpl	.-8      	; 0x1e7e <DIO_voidSetPinVal+0xbe>
    1e86:	80 95       	com	r24
    1e88:	82 23       	and	r24, r18
    1e8a:	85 bb       	out	0x15, r24	; 21
    1e8c:	08 95       	ret
    1e8e:	22 b3       	in	r18, 0x12	; 18
    1e90:	81 e0       	ldi	r24, 0x01	; 1
    1e92:	90 e0       	ldi	r25, 0x00	; 0
    1e94:	02 c0       	rjmp	.+4      	; 0x1e9a <DIO_voidSetPinVal+0xda>
    1e96:	88 0f       	add	r24, r24
    1e98:	99 1f       	adc	r25, r25
    1e9a:	6a 95       	dec	r22
    1e9c:	e2 f7       	brpl	.-8      	; 0x1e96 <DIO_voidSetPinVal+0xd6>
    1e9e:	80 95       	com	r24
    1ea0:	82 23       	and	r24, r18
    1ea2:	82 bb       	out	0x12, r24	; 18
    1ea4:	08 95       	ret

00001ea6 <DIO_u8ReadpinVal>:

u8 DIO_u8ReadpinVal(u8 copy_u8port, u8 copy_u8pin){
	
	 u8 Loc_u8Val=0 ; 
	 
	  switch(copy_u8port){
    1ea6:	81 30       	cpi	r24, 0x01	; 1
    1ea8:	79 f0       	breq	.+30     	; 0x1ec8 <DIO_u8ReadpinVal+0x22>
    1eaa:	28 f0       	brcs	.+10     	; 0x1eb6 <DIO_u8ReadpinVal+0x10>
    1eac:	82 30       	cpi	r24, 0x02	; 2
    1eae:	a9 f0       	breq	.+42     	; 0x1eda <DIO_u8ReadpinVal+0x34>
    1eb0:	83 30       	cpi	r24, 0x03	; 3
    1eb2:	e1 f0       	breq	.+56     	; 0x1eec <DIO_u8ReadpinVal+0x46>
    1eb4:	24 c0       	rjmp	.+72     	; 0x1efe <DIO_u8ReadpinVal+0x58>
		  
		  case DIO_PORTA:Loc_u8Val = GET_BIT(PINA_REG,copy_u8pin) ; break;
    1eb6:	89 b3       	in	r24, 0x19	; 25
    1eb8:	90 e0       	ldi	r25, 0x00	; 0
    1eba:	02 c0       	rjmp	.+4      	; 0x1ec0 <DIO_u8ReadpinVal+0x1a>
    1ebc:	95 95       	asr	r25
    1ebe:	87 95       	ror	r24
    1ec0:	6a 95       	dec	r22
    1ec2:	e2 f7       	brpl	.-8      	; 0x1ebc <DIO_u8ReadpinVal+0x16>
    1ec4:	81 70       	andi	r24, 0x01	; 1
    1ec6:	08 95       	ret
		  case DIO_PORTB:Loc_u8Val = GET_BIT(PINB_REG,copy_u8pin) ; break;
    1ec8:	86 b3       	in	r24, 0x16	; 22
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	02 c0       	rjmp	.+4      	; 0x1ed2 <DIO_u8ReadpinVal+0x2c>
    1ece:	95 95       	asr	r25
    1ed0:	87 95       	ror	r24
    1ed2:	6a 95       	dec	r22
    1ed4:	e2 f7       	brpl	.-8      	; 0x1ece <DIO_u8ReadpinVal+0x28>
    1ed6:	81 70       	andi	r24, 0x01	; 1
    1ed8:	08 95       	ret
		  case DIO_PORTC:Loc_u8Val = GET_BIT(PINC_REG,copy_u8pin) ; break;
    1eda:	83 b3       	in	r24, 0x13	; 19
    1edc:	90 e0       	ldi	r25, 0x00	; 0
    1ede:	02 c0       	rjmp	.+4      	; 0x1ee4 <DIO_u8ReadpinVal+0x3e>
    1ee0:	95 95       	asr	r25
    1ee2:	87 95       	ror	r24
    1ee4:	6a 95       	dec	r22
    1ee6:	e2 f7       	brpl	.-8      	; 0x1ee0 <DIO_u8ReadpinVal+0x3a>
    1ee8:	81 70       	andi	r24, 0x01	; 1
    1eea:	08 95       	ret
		  case DIO_PORTD:Loc_u8Val = GET_BIT(PIND_REG,copy_u8pin) ; break ;
    1eec:	80 b3       	in	r24, 0x10	; 16
    1eee:	90 e0       	ldi	r25, 0x00	; 0
    1ef0:	02 c0       	rjmp	.+4      	; 0x1ef6 <DIO_u8ReadpinVal+0x50>
    1ef2:	95 95       	asr	r25
    1ef4:	87 95       	ror	r24
    1ef6:	6a 95       	dec	r22
    1ef8:	e2 f7       	brpl	.-8      	; 0x1ef2 <DIO_u8ReadpinVal+0x4c>
    1efa:	81 70       	andi	r24, 0x01	; 1
    1efc:	08 95       	ret
	
}

u8 DIO_u8ReadpinVal(u8 copy_u8port, u8 copy_u8pin){
	
	 u8 Loc_u8Val=0 ; 
    1efe:	80 e0       	ldi	r24, 0x00	; 0
	
	
	return Loc_u8Val ; 
	
	
}
    1f00:	08 95       	ret

00001f02 <DIO_voidSetPortDir>:
void DIO_voidSetPortDir(u8 copy_u8port, u8 copy_u8dir)
{
	switch(copy_u8port)
    1f02:	81 30       	cpi	r24, 0x01	; 1
    1f04:	41 f0       	breq	.+16     	; 0x1f16 <DIO_voidSetPortDir+0x14>
    1f06:	28 f0       	brcs	.+10     	; 0x1f12 <DIO_voidSetPortDir+0x10>
    1f08:	82 30       	cpi	r24, 0x02	; 2
    1f0a:	39 f0       	breq	.+14     	; 0x1f1a <DIO_voidSetPortDir+0x18>
    1f0c:	83 30       	cpi	r24, 0x03	; 3
    1f0e:	39 f0       	breq	.+14     	; 0x1f1e <DIO_voidSetPortDir+0x1c>
    1f10:	08 95       	ret
	{
		
		case DIO_PORTA: DDRA_REG=copy_u8dir ; break;
    1f12:	6a bb       	out	0x1a, r22	; 26
    1f14:	08 95       	ret
		case DIO_PORTB: DDRB_REG=copy_u8dir ; break;
    1f16:	67 bb       	out	0x17, r22	; 23
    1f18:	08 95       	ret
		case DIO_PORTC: DDRC_REG=copy_u8dir ; break;
    1f1a:	64 bb       	out	0x14, r22	; 20
    1f1c:	08 95       	ret
		case DIO_PORTD: DDRD_REG=copy_u8dir ; break ;
    1f1e:	61 bb       	out	0x11, r22	; 17
    1f20:	08 95       	ret

00001f22 <DIO_voidSetPortVal>:
	}
	
}
void DIO_voidSetPortVal(u8 copy_u8port, u8 copy_u8val) 
{
	switch(copy_u8port)
    1f22:	81 30       	cpi	r24, 0x01	; 1
    1f24:	41 f0       	breq	.+16     	; 0x1f36 <DIO_voidSetPortVal+0x14>
    1f26:	28 f0       	brcs	.+10     	; 0x1f32 <DIO_voidSetPortVal+0x10>
    1f28:	82 30       	cpi	r24, 0x02	; 2
    1f2a:	39 f0       	breq	.+14     	; 0x1f3a <DIO_voidSetPortVal+0x18>
    1f2c:	83 30       	cpi	r24, 0x03	; 3
    1f2e:	39 f0       	breq	.+14     	; 0x1f3e <DIO_voidSetPortVal+0x1c>
    1f30:	08 95       	ret
	{
		
		case DIO_PORTA: PORTA_REG=copy_u8val ; break;
    1f32:	6b bb       	out	0x1b, r22	; 27
    1f34:	08 95       	ret
		case DIO_PORTB: PORTB_REG=copy_u8val ; break;
    1f36:	68 bb       	out	0x18, r22	; 24
    1f38:	08 95       	ret
		case DIO_PORTC: PORTC_REG=copy_u8val ; break;
    1f3a:	65 bb       	out	0x15, r22	; 21
    1f3c:	08 95       	ret
		case DIO_PORTD: PORTD_REG=copy_u8val ; break ;
    1f3e:	62 bb       	out	0x12, r22	; 18
    1f40:	08 95       	ret

00001f42 <__vector_1>:
void EXT2_voidDisable(void){
	
	CLR_BIT(GICR_REG,5) ;
	
}
ISR(INT_0)	{
    1f42:	1f 92       	push	r1
    1f44:	0f 92       	push	r0
    1f46:	0f b6       	in	r0, 0x3f	; 63
    1f48:	0f 92       	push	r0
    1f4a:	11 24       	eor	r1, r1
    1f4c:	2f 93       	push	r18
    1f4e:	3f 93       	push	r19
    1f50:	4f 93       	push	r20
    1f52:	5f 93       	push	r21
    1f54:	6f 93       	push	r22
    1f56:	7f 93       	push	r23
    1f58:	8f 93       	push	r24
    1f5a:	9f 93       	push	r25
    1f5c:	af 93       	push	r26
    1f5e:	bf 93       	push	r27
    1f60:	ef 93       	push	r30
    1f62:	ff 93       	push	r31
	INT_PTR[0]();
    1f64:	e0 91 eb 04 	lds	r30, 0x04EB	; 0x8004eb <INT_PTR>
    1f68:	f0 91 ec 04 	lds	r31, 0x04EC	; 0x8004ec <INT_PTR+0x1>
    1f6c:	09 95       	icall
}
    1f6e:	ff 91       	pop	r31
    1f70:	ef 91       	pop	r30
    1f72:	bf 91       	pop	r27
    1f74:	af 91       	pop	r26
    1f76:	9f 91       	pop	r25
    1f78:	8f 91       	pop	r24
    1f7a:	7f 91       	pop	r23
    1f7c:	6f 91       	pop	r22
    1f7e:	5f 91       	pop	r21
    1f80:	4f 91       	pop	r20
    1f82:	3f 91       	pop	r19
    1f84:	2f 91       	pop	r18
    1f86:	0f 90       	pop	r0
    1f88:	0f be       	out	0x3f, r0	; 63
    1f8a:	0f 90       	pop	r0
    1f8c:	1f 90       	pop	r1
    1f8e:	18 95       	reti

00001f90 <__vector_2>:


ISR(INT_1)	{
    1f90:	1f 92       	push	r1
    1f92:	0f 92       	push	r0
    1f94:	0f b6       	in	r0, 0x3f	; 63
    1f96:	0f 92       	push	r0
    1f98:	11 24       	eor	r1, r1
    1f9a:	2f 93       	push	r18
    1f9c:	3f 93       	push	r19
    1f9e:	4f 93       	push	r20
    1fa0:	5f 93       	push	r21
    1fa2:	6f 93       	push	r22
    1fa4:	7f 93       	push	r23
    1fa6:	8f 93       	push	r24
    1fa8:	9f 93       	push	r25
    1faa:	af 93       	push	r26
    1fac:	bf 93       	push	r27
    1fae:	ef 93       	push	r30
    1fb0:	ff 93       	push	r31
	
	INT_PTR[1]() ;
    1fb2:	e0 91 ed 04 	lds	r30, 0x04ED	; 0x8004ed <INT_PTR+0x2>
    1fb6:	f0 91 ee 04 	lds	r31, 0x04EE	; 0x8004ee <INT_PTR+0x3>
    1fba:	09 95       	icall
}
    1fbc:	ff 91       	pop	r31
    1fbe:	ef 91       	pop	r30
    1fc0:	bf 91       	pop	r27
    1fc2:	af 91       	pop	r26
    1fc4:	9f 91       	pop	r25
    1fc6:	8f 91       	pop	r24
    1fc8:	7f 91       	pop	r23
    1fca:	6f 91       	pop	r22
    1fcc:	5f 91       	pop	r21
    1fce:	4f 91       	pop	r20
    1fd0:	3f 91       	pop	r19
    1fd2:	2f 91       	pop	r18
    1fd4:	0f 90       	pop	r0
    1fd6:	0f be       	out	0x3f, r0	; 63
    1fd8:	0f 90       	pop	r0
    1fda:	1f 90       	pop	r1
    1fdc:	18 95       	reti

00001fde <__vector_3>:

ISR(INT_2)	{
    1fde:	1f 92       	push	r1
    1fe0:	0f 92       	push	r0
    1fe2:	0f b6       	in	r0, 0x3f	; 63
    1fe4:	0f 92       	push	r0
    1fe6:	11 24       	eor	r1, r1
    1fe8:	2f 93       	push	r18
    1fea:	3f 93       	push	r19
    1fec:	4f 93       	push	r20
    1fee:	5f 93       	push	r21
    1ff0:	6f 93       	push	r22
    1ff2:	7f 93       	push	r23
    1ff4:	8f 93       	push	r24
    1ff6:	9f 93       	push	r25
    1ff8:	af 93       	push	r26
    1ffa:	bf 93       	push	r27
    1ffc:	ef 93       	push	r30
    1ffe:	ff 93       	push	r31
	INT_PTR[2]() ;
    2000:	e0 91 ef 04 	lds	r30, 0x04EF	; 0x8004ef <INT_PTR+0x4>
    2004:	f0 91 f0 04 	lds	r31, 0x04F0	; 0x8004f0 <INT_PTR+0x5>
    2008:	09 95       	icall
}
    200a:	ff 91       	pop	r31
    200c:	ef 91       	pop	r30
    200e:	bf 91       	pop	r27
    2010:	af 91       	pop	r26
    2012:	9f 91       	pop	r25
    2014:	8f 91       	pop	r24
    2016:	7f 91       	pop	r23
    2018:	6f 91       	pop	r22
    201a:	5f 91       	pop	r21
    201c:	4f 91       	pop	r20
    201e:	3f 91       	pop	r19
    2020:	2f 91       	pop	r18
    2022:	0f 90       	pop	r0
    2024:	0f be       	out	0x3f, r0	; 63
    2026:	0f 90       	pop	r0
    2028:	1f 90       	pop	r1
    202a:	18 95       	reti

0000202c <GI_voidEnable>:



void GI_voidEnable(void) {
	
	SET_BIT(SREG_REG,7) ; 
    202c:	8f b7       	in	r24, 0x3f	; 63
    202e:	80 68       	ori	r24, 0x80	; 128
    2030:	8f bf       	out	0x3f, r24	; 63
    2032:	08 95       	ret

00002034 <TIM0_voidInitCTC_OV>:
	#elif FASTPWMMODE == INVERTING_MODE
	SET_BIT(TCCR0_REG,5);
	SET_BIT(TCCR0_REG,4);
	#endif

	OCR0_REG=copy_dc*2.56;
    2034:	93 b7       	in	r25, 0x33	; 51
    2036:	98 7f       	andi	r25, 0xF8	; 248
    2038:	93 bf       	out	0x33, r25	; 51
    203a:	93 b7       	in	r25, 0x33	; 51
    203c:	93 60       	ori	r25, 0x03	; 3
    203e:	93 bf       	out	0x33, r25	; 51
    2040:	81 11       	cpse	r24, r1
    2042:	0a c0       	rjmp	.+20     	; 0x2058 <TIM0_voidInitCTC_OV+0x24>
    2044:	83 b7       	in	r24, 0x33	; 51
    2046:	87 7f       	andi	r24, 0xF7	; 247
    2048:	83 bf       	out	0x33, r24	; 51
    204a:	83 b7       	in	r24, 0x33	; 51
    204c:	8f 7b       	andi	r24, 0xBF	; 191
    204e:	83 bf       	out	0x33, r24	; 51
    2050:	89 b7       	in	r24, 0x39	; 57
    2052:	81 60       	ori	r24, 0x01	; 1
    2054:	89 bf       	out	0x39, r24	; 57
    2056:	08 95       	ret
    2058:	81 30       	cpi	r24, 0x01	; 1
    205a:	59 f4       	brne	.+22     	; 0x2072 <TIM0_voidInitCTC_OV+0x3e>
    205c:	83 b7       	in	r24, 0x33	; 51
    205e:	88 60       	ori	r24, 0x08	; 8
    2060:	83 bf       	out	0x33, r24	; 51
    2062:	83 b7       	in	r24, 0x33	; 51
    2064:	8f 7b       	andi	r24, 0xBF	; 191
    2066:	83 bf       	out	0x33, r24	; 51
    2068:	89 b7       	in	r24, 0x39	; 57
    206a:	82 60       	ori	r24, 0x02	; 2
    206c:	89 bf       	out	0x39, r24	; 57
    206e:	89 ef       	ldi	r24, 0xF9	; 249
    2070:	8c bf       	out	0x3c, r24	; 60
    2072:	08 95       	ret

00002074 <TIM0_voidSetCallBack>:


void TIM0_voidSetCallBack(void(*ptr)(void) , u8 interrupt_mode){
	
	
	 switch(interrupt_mode){
    2074:	66 23       	and	r22, r22
    2076:	19 f0       	breq	.+6      	; 0x207e <TIM0_voidSetCallBack+0xa>
    2078:	61 30       	cpi	r22, 0x01	; 1
    207a:	31 f0       	breq	.+12     	; 0x2088 <TIM0_voidSetCallBack+0x14>
    207c:	08 95       	ret
		 
		 case OV_MODE :  TIM0_PTR[0]=ptr ; break; 
    207e:	90 93 f2 04 	sts	0x04F2, r25	; 0x8004f2 <TIM0_PTR+0x1>
    2082:	80 93 f1 04 	sts	0x04F1, r24	; 0x8004f1 <TIM0_PTR>
    2086:	08 95       	ret
		 case CTC_MODE : TIM0_PTR[1]=ptr ; break; 
    2088:	90 93 f4 04 	sts	0x04F4, r25	; 0x8004f4 <TIM0_PTR+0x3>
    208c:	80 93 f3 04 	sts	0x04F3, r24	; 0x8004f3 <TIM0_PTR+0x2>
    2090:	08 95       	ret

00002092 <__vector_11>:
}




ISR(TIMER0_OVF){
    2092:	1f 92       	push	r1
    2094:	0f 92       	push	r0
    2096:	0f b6       	in	r0, 0x3f	; 63
    2098:	0f 92       	push	r0
    209a:	11 24       	eor	r1, r1
    209c:	2f 93       	push	r18
    209e:	3f 93       	push	r19
    20a0:	4f 93       	push	r20
    20a2:	5f 93       	push	r21
    20a4:	6f 93       	push	r22
    20a6:	7f 93       	push	r23
    20a8:	8f 93       	push	r24
    20aa:	9f 93       	push	r25
    20ac:	af 93       	push	r26
    20ae:	bf 93       	push	r27
    20b0:	ef 93       	push	r30
    20b2:	ff 93       	push	r31
	

	TIM0_PTR[0]() ; 
    20b4:	e0 91 f1 04 	lds	r30, 0x04F1	; 0x8004f1 <TIM0_PTR>
    20b8:	f0 91 f2 04 	lds	r31, 0x04F2	; 0x8004f2 <TIM0_PTR+0x1>
    20bc:	09 95       	icall
	
}
    20be:	ff 91       	pop	r31
    20c0:	ef 91       	pop	r30
    20c2:	bf 91       	pop	r27
    20c4:	af 91       	pop	r26
    20c6:	9f 91       	pop	r25
    20c8:	8f 91       	pop	r24
    20ca:	7f 91       	pop	r23
    20cc:	6f 91       	pop	r22
    20ce:	5f 91       	pop	r21
    20d0:	4f 91       	pop	r20
    20d2:	3f 91       	pop	r19
    20d4:	2f 91       	pop	r18
    20d6:	0f 90       	pop	r0
    20d8:	0f be       	out	0x3f, r0	; 63
    20da:	0f 90       	pop	r0
    20dc:	1f 90       	pop	r1
    20de:	18 95       	reti

000020e0 <__vector_10>:


ISR(TIMER0_COMP){
    20e0:	1f 92       	push	r1
    20e2:	0f 92       	push	r0
    20e4:	0f b6       	in	r0, 0x3f	; 63
    20e6:	0f 92       	push	r0
    20e8:	11 24       	eor	r1, r1
    20ea:	2f 93       	push	r18
    20ec:	3f 93       	push	r19
    20ee:	4f 93       	push	r20
    20f0:	5f 93       	push	r21
    20f2:	6f 93       	push	r22
    20f4:	7f 93       	push	r23
    20f6:	8f 93       	push	r24
    20f8:	9f 93       	push	r25
    20fa:	af 93       	push	r26
    20fc:	bf 93       	push	r27
    20fe:	ef 93       	push	r30
    2100:	ff 93       	push	r31
	TIM0_PTR[1]() ; 
    2102:	e0 91 f3 04 	lds	r30, 0x04F3	; 0x8004f3 <TIM0_PTR+0x2>
    2106:	f0 91 f4 04 	lds	r31, 0x04F4	; 0x8004f4 <TIM0_PTR+0x3>
    210a:	09 95       	icall
	
	
    210c:	ff 91       	pop	r31
    210e:	ef 91       	pop	r30
    2110:	bf 91       	pop	r27
    2112:	af 91       	pop	r26
    2114:	9f 91       	pop	r25
    2116:	8f 91       	pop	r24
    2118:	7f 91       	pop	r23
    211a:	6f 91       	pop	r22
    211c:	5f 91       	pop	r21
    211e:	4f 91       	pop	r20
    2120:	3f 91       	pop	r19
    2122:	2f 91       	pop	r18
    2124:	0f 90       	pop	r0
    2126:	0f be       	out	0x3f, r0	; 63
    2128:	0f 90       	pop	r0
    212a:	1f 90       	pop	r1
    212c:	18 95       	reti

0000212e <TIM2_voidFastPWM>:
	
	
	switch(interrupt_mode){
		
		case OV_MODE :  TIM2_PTR[0]=ptr ; break;
		case CTC_MODE : TIM2_PTR[1]=ptr ; break;
    212e:	95 b5       	in	r25, 0x25	; 37
    2130:	98 60       	ori	r25, 0x08	; 8
    2132:	95 bd       	out	0x25, r25	; 37
    2134:	95 b5       	in	r25, 0x25	; 37
    2136:	90 64       	ori	r25, 0x40	; 64
    2138:	95 bd       	out	0x25, r25	; 37
    213a:	95 b5       	in	r25, 0x25	; 37
    213c:	98 7f       	andi	r25, 0xF8	; 248
    213e:	95 bd       	out	0x25, r25	; 37
    2140:	95 b5       	in	r25, 0x25	; 37
    2142:	93 60       	ori	r25, 0x03	; 3
    2144:	95 bd       	out	0x25, r25	; 37
    2146:	95 b5       	in	r25, 0x25	; 37
    2148:	90 62       	ori	r25, 0x20	; 32
    214a:	95 bd       	out	0x25, r25	; 37
    214c:	95 b5       	in	r25, 0x25	; 37
    214e:	9f 7e       	andi	r25, 0xEF	; 239
    2150:	95 bd       	out	0x25, r25	; 37
    2152:	68 2f       	mov	r22, r24
    2154:	70 e0       	ldi	r23, 0x00	; 0
    2156:	80 e0       	ldi	r24, 0x00	; 0
    2158:	90 e0       	ldi	r25, 0x00	; 0
    215a:	0e 94 9f 12 	call	0x253e	; 0x253e <__floatsisf>
    215e:	2a e0       	ldi	r18, 0x0A	; 10
    2160:	37 ed       	ldi	r19, 0xD7	; 215
    2162:	43 e2       	ldi	r20, 0x23	; 35
    2164:	50 e4       	ldi	r21, 0x40	; 64
    2166:	0e 94 2b 13 	call	0x2656	; 0x2656 <__mulsf3>
    216a:	0e 94 6e 12 	call	0x24dc	; 0x24dc <__fixunssfsi>
    216e:	63 bd       	out	0x23, r22	; 35
    2170:	08 95       	ret

00002172 <__vector_5>:
}




ISR(TIMER2_OVF){
    2172:	1f 92       	push	r1
    2174:	0f 92       	push	r0
    2176:	0f b6       	in	r0, 0x3f	; 63
    2178:	0f 92       	push	r0
    217a:	11 24       	eor	r1, r1
    217c:	2f 93       	push	r18
    217e:	3f 93       	push	r19
    2180:	4f 93       	push	r20
    2182:	5f 93       	push	r21
    2184:	6f 93       	push	r22
    2186:	7f 93       	push	r23
    2188:	8f 93       	push	r24
    218a:	9f 93       	push	r25
    218c:	af 93       	push	r26
    218e:	bf 93       	push	r27
    2190:	ef 93       	push	r30
    2192:	ff 93       	push	r31
	

	TIM2_PTR[0]() ;
    2194:	e0 91 f5 04 	lds	r30, 0x04F5	; 0x8004f5 <TIM2_PTR>
    2198:	f0 91 f6 04 	lds	r31, 0x04F6	; 0x8004f6 <TIM2_PTR+0x1>
    219c:	09 95       	icall
	
}
    219e:	ff 91       	pop	r31
    21a0:	ef 91       	pop	r30
    21a2:	bf 91       	pop	r27
    21a4:	af 91       	pop	r26
    21a6:	9f 91       	pop	r25
    21a8:	8f 91       	pop	r24
    21aa:	7f 91       	pop	r23
    21ac:	6f 91       	pop	r22
    21ae:	5f 91       	pop	r21
    21b0:	4f 91       	pop	r20
    21b2:	3f 91       	pop	r19
    21b4:	2f 91       	pop	r18
    21b6:	0f 90       	pop	r0
    21b8:	0f be       	out	0x3f, r0	; 63
    21ba:	0f 90       	pop	r0
    21bc:	1f 90       	pop	r1
    21be:	18 95       	reti

000021c0 <__vector_4>:


ISR(TIMER2_COMP){
    21c0:	1f 92       	push	r1
    21c2:	0f 92       	push	r0
    21c4:	0f b6       	in	r0, 0x3f	; 63
    21c6:	0f 92       	push	r0
    21c8:	11 24       	eor	r1, r1
    21ca:	2f 93       	push	r18
    21cc:	3f 93       	push	r19
    21ce:	4f 93       	push	r20
    21d0:	5f 93       	push	r21
    21d2:	6f 93       	push	r22
    21d4:	7f 93       	push	r23
    21d6:	8f 93       	push	r24
    21d8:	9f 93       	push	r25
    21da:	af 93       	push	r26
    21dc:	bf 93       	push	r27
    21de:	ef 93       	push	r30
    21e0:	ff 93       	push	r31
	TIM2_PTR[1]() ;
    21e2:	e0 91 f7 04 	lds	r30, 0x04F7	; 0x8004f7 <TIM2_PTR+0x2>
    21e6:	f0 91 f8 04 	lds	r31, 0x04F8	; 0x8004f8 <TIM2_PTR+0x3>
    21ea:	09 95       	icall
	
	
    21ec:	ff 91       	pop	r31
    21ee:	ef 91       	pop	r30
    21f0:	bf 91       	pop	r27
    21f2:	af 91       	pop	r26
    21f4:	9f 91       	pop	r25
    21f6:	8f 91       	pop	r24
    21f8:	7f 91       	pop	r23
    21fa:	6f 91       	pop	r22
    21fc:	5f 91       	pop	r21
    21fe:	4f 91       	pop	r20
    2200:	3f 91       	pop	r19
    2202:	2f 91       	pop	r18
    2204:	0f 90       	pop	r0
    2206:	0f be       	out	0x3f, r0	; 63
    2208:	0f 90       	pop	r0
    220a:	1f 90       	pop	r1
    220c:	18 95       	reti

0000220e <TWI_voidMasterInit>:
	
	/* Enable ACK */
	SET_BIT(TWCR_REG,6) ;
	
	/* ENABLE TWI */
	SET_BIT(TWCR_REG,2) ;
    220e:	9c e0       	ldi	r25, 0x0C	; 12
    2210:	90 b9       	out	0x00, r25	; 0
    2212:	91 b1       	in	r25, 0x01	; 1
    2214:	9e 7f       	andi	r25, 0xFE	; 254
    2216:	91 b9       	out	0x01, r25	; 1
    2218:	91 b1       	in	r25, 0x01	; 1
    221a:	9d 7f       	andi	r25, 0xFD	; 253
    221c:	91 b9       	out	0x01, r25	; 1
    221e:	88 23       	and	r24, r24
    2220:	11 f0       	breq	.+4      	; 0x2226 <TWI_voidMasterInit+0x18>
    2222:	88 0f       	add	r24, r24
    2224:	82 b9       	out	0x02, r24	; 2
    2226:	86 b7       	in	r24, 0x36	; 54
    2228:	80 64       	ori	r24, 0x40	; 64
    222a:	86 bf       	out	0x36, r24	; 54
    222c:	86 b7       	in	r24, 0x36	; 54
    222e:	84 60       	ori	r24, 0x04	; 4
    2230:	86 bf       	out	0x36, r24	; 54
    2232:	08 95       	ret

00002234 <TWI_TWI_statusStartCondition>:

TWI_status  TWI_TWI_statusStartCondition(void){
	
	TWI_status LOC_TWI_statusVal=NOErr ; 
         /* send start condition */	
		 SET_BIT(TWCR_REG,5) ; 
    2234:	86 b7       	in	r24, 0x36	; 54
    2236:	80 62       	ori	r24, 0x20	; 32
    2238:	86 bf       	out	0x36, r24	; 54
	
	   /* CLR flag To send start condition */
	   SET_BIT(TWCR_REG,7) ; 
    223a:	86 b7       	in	r24, 0x36	; 54
    223c:	80 68       	ori	r24, 0x80	; 128
    223e:	86 bf       	out	0x36, r24	; 54
	   
	   /* WAIT TWI has finished  current job*/
	   while(GET_BIT(TWCR_REG,7)==0) ; 
    2240:	06 b6       	in	r0, 0x36	; 54
    2242:	07 fe       	sbrs	r0, 7
    2244:	fd cf       	rjmp	.-6      	; 0x2240 <TWI_TWI_statusStartCondition+0xc>
	   
	   if ((TWSR_REG & 0xF8)  != START_ACK)           
    2246:	81 b1       	in	r24, 0x01	; 1
    2248:	88 7f       	andi	r24, 0xF8	; 248
    224a:	88 30       	cpi	r24, 0x08	; 8
    224c:	11 f4       	brne	.+4      	; 0x2252 <TWI_TWI_statusStartCondition+0x1e>
	SET_BIT(TWCR_REG,2) ;
}

TWI_status  TWI_TWI_statusStartCondition(void){
	
	TWI_status LOC_TWI_statusVal=NOErr ; 
    224e:	80 e0       	ldi	r24, 0x00	; 0
    2250:	08 95       	ret
	   /* WAIT TWI has finished  current job*/
	   while(GET_BIT(TWCR_REG,7)==0) ; 
	   
	   if ((TWSR_REG & 0xF8)  != START_ACK)           
	   {
		   LOC_TWI_statusVal=StartConditionErr ; 
    2252:	81 e0       	ldi	r24, 0x01	; 1
		    // do noting 
	   }
	
	return LOC_TWI_statusVal ; 
	
}
    2254:	08 95       	ret

00002256 <TWI_TWI_statusRepeatedStart>:

TWI_status TWI_TWI_statusRepeatedStart(void) {
	
	TWI_status LOC_TWI_statusVal=NOErr ;
	/* send start condition */
	SET_BIT(TWCR_REG,5) ;
    2256:	86 b7       	in	r24, 0x36	; 54
    2258:	80 62       	ori	r24, 0x20	; 32
    225a:	86 bf       	out	0x36, r24	; 54
	
	/* CLR flag To send start condition */
	SET_BIT(TWCR_REG,7) ;
    225c:	86 b7       	in	r24, 0x36	; 54
    225e:	80 68       	ori	r24, 0x80	; 128
    2260:	86 bf       	out	0x36, r24	; 54
	
	/* WAIT TWI has finished  current job*/
	while(GET_BIT(TWCR_REG,7)==0) ;
    2262:	06 b6       	in	r0, 0x36	; 54
    2264:	07 fe       	sbrs	r0, 7
    2266:	fd cf       	rjmp	.-6      	; 0x2262 <TWI_TWI_statusRepeatedStart+0xc>
	
	if ((TWSR_REG & 0xF8) != REP_START)
    2268:	81 b1       	in	r24, 0x01	; 1
    226a:	88 7f       	andi	r24, 0xF8	; 248
    226c:	80 31       	cpi	r24, 0x10	; 16
    226e:	11 f4       	brne	.+4      	; 0x2274 <TWI_TWI_statusRepeatedStart+0x1e>
	
}

TWI_status TWI_TWI_statusRepeatedStart(void) {
	
	TWI_status LOC_TWI_statusVal=NOErr ;
    2270:	80 e0       	ldi	r24, 0x00	; 0
    2272:	08 95       	ret
	/* WAIT TWI has finished  current job*/
	while(GET_BIT(TWCR_REG,7)==0) ;
	
	if ((TWSR_REG & 0xF8) != REP_START)
	{
		LOC_TWI_statusVal=RepeatedStartErr ;
    2274:	82 e0       	ldi	r24, 0x02	; 2
		// do noting
	}
	
	return LOC_TWI_statusVal ;
	
}
    2276:	08 95       	ret

00002278 <TWI_TWI_statusSendSlaveAdressWithWrite>:
	
	TWI_status LOC_TWI_statusVal=NOErr ;
	
	   /* send salve to SDA LINE */
	
	  TWDR_REG=copy_u8address<<1;
    2278:	88 0f       	add	r24, r24
    227a:	83 b9       	out	0x03, r24	; 3
	  /* CLR BIT0  TO Write */
	   CLR_BIT(TWDR_REG,0) ; 
    227c:	83 b1       	in	r24, 0x03	; 3
    227e:	8e 7f       	andi	r24, 0xFE	; 254
    2280:	83 b9       	out	0x03, r24	; 3
	   /* clr start condition */
	   CLR_BIT(TWCR_REG,5) ; 
    2282:	86 b7       	in	r24, 0x36	; 54
    2284:	8f 7d       	andi	r24, 0xDF	; 223
    2286:	86 bf       	out	0x36, r24	; 54
	   /* CLR flag To send  save address  */
	   SET_BIT(TWCR_REG,7) ;
    2288:	86 b7       	in	r24, 0x36	; 54
    228a:	80 68       	ori	r24, 0x80	; 128
    228c:	86 bf       	out	0x36, r24	; 54
	   
	   /* WAIT TWI has finished  current job*/
	   while(GET_BIT(TWCR_REG,7)==0) ;
    228e:	06 b6       	in	r0, 0x36	; 54
    2290:	07 fe       	sbrs	r0, 7
    2292:	fd cf       	rjmp	.-6      	; 0x228e <TWI_TWI_statusSendSlaveAdressWithWrite+0x16>
	   
	
	
	
	if ((TWSR_REG & 0xF8)  != SLAVE_ADD_AND_WR_ACK)
    2294:	81 b1       	in	r24, 0x01	; 1
    2296:	88 7f       	andi	r24, 0xF8	; 248
    2298:	88 31       	cpi	r24, 0x18	; 24
    229a:	11 f4       	brne	.+4      	; 0x22a0 <TWI_TWI_statusSendSlaveAdressWithWrite+0x28>
	
}

TWI_status TWI_TWI_statusSendSlaveAdressWithWrite(u8 copy_u8address){
	
	TWI_status LOC_TWI_statusVal=NOErr ;
    229c:	80 e0       	ldi	r24, 0x00	; 0
    229e:	08 95       	ret
	
	
	
	if ((TWSR_REG & 0xF8)  != SLAVE_ADD_AND_WR_ACK)
	{
		LOC_TWI_statusVal=SendSlaveAdressWithWriteErr ;
    22a0:	83 e0       	ldi	r24, 0x03	; 3
		// do noting
	}
	
	return LOC_TWI_statusVal ;
	
}
    22a2:	08 95       	ret

000022a4 <TWI_TWI_statusSendSlaveAdressWithRead>:
	
	TWI_status LOC_TWI_statusVal=NOErr ;
	
	/* send salve to SDA LINE */
	
	TWDR_REG=copy_u8address<<1;
    22a4:	88 0f       	add	r24, r24
    22a6:	83 b9       	out	0x03, r24	; 3
	/* CLR BIT0  TO Read */
	   SET_BIT(TWDR_REG,0) ;
    22a8:	83 b1       	in	r24, 0x03	; 3
    22aa:	81 60       	ori	r24, 0x01	; 1
    22ac:	83 b9       	out	0x03, r24	; 3
	/* clr start condition */
	CLR_BIT(TWCR_REG,5) ;
    22ae:	86 b7       	in	r24, 0x36	; 54
    22b0:	8f 7d       	andi	r24, 0xDF	; 223
    22b2:	86 bf       	out	0x36, r24	; 54
	/* CLR flag To send  save address  */
	SET_BIT(TWCR_REG,7) ;
    22b4:	86 b7       	in	r24, 0x36	; 54
    22b6:	80 68       	ori	r24, 0x80	; 128
    22b8:	86 bf       	out	0x36, r24	; 54
	
	/* WAIT TWI has finished  current job*/
	while(GET_BIT(TWCR_REG,7)==0) ;
    22ba:	06 b6       	in	r0, 0x36	; 54
    22bc:	07 fe       	sbrs	r0, 7
    22be:	fd cf       	rjmp	.-6      	; 0x22ba <TWI_TWI_statusSendSlaveAdressWithRead+0x16>

	if ((TWSR_REG & 0xF8)  != SLAVE_ADD_AND_RR_ACK)
    22c0:	81 b1       	in	r24, 0x01	; 1
    22c2:	88 7f       	andi	r24, 0xF8	; 248
    22c4:	80 34       	cpi	r24, 0x40	; 64
    22c6:	11 f4       	brne	.+4      	; 0x22cc <TWI_TWI_statusSendSlaveAdressWithRead+0x28>
	return LOC_TWI_statusVal ;
	
}
TWI_status TWI_TWI_statusSendSlaveAdressWithRead(u8 copy_u8address){
	
	TWI_status LOC_TWI_statusVal=NOErr ;
    22c8:	80 e0       	ldi	r24, 0x00	; 0
    22ca:	08 95       	ret
	/* WAIT TWI has finished  current job*/
	while(GET_BIT(TWCR_REG,7)==0) ;

	if ((TWSR_REG & 0xF8)  != SLAVE_ADD_AND_RR_ACK)
	{
		LOC_TWI_statusVal=SendSlaveAdressWithReadErr ;
    22cc:	84 e0       	ldi	r24, 0x04	; 4
		// do noting
	}
	
	return LOC_TWI_statusVal ;
	
}
    22ce:	08 95       	ret

000022d0 <TWI_TWI_statusMasterSendData>:
	
	TWI_status LOC_TWI_statusVal=NOErr ;
	
	/* load data to bus */
	
	TWDR_REG=copy_u8data ; 
    22d0:	83 b9       	out	0x03, r24	; 3
	
	/* CLR flag To send  save address  */
	SET_BIT(TWCR_REG,7) ;
    22d2:	86 b7       	in	r24, 0x36	; 54
    22d4:	80 68       	ori	r24, 0x80	; 128
    22d6:	86 bf       	out	0x36, r24	; 54
	
	/* WAIT TWI has finished  current job*/
	while(GET_BIT(TWCR_REG,7)==0);
    22d8:	06 b6       	in	r0, 0x36	; 54
    22da:	07 fe       	sbrs	r0, 7
    22dc:	fd cf       	rjmp	.-6      	; 0x22d8 <TWI_TWI_statusMasterSendData+0x8>
	
	
	
	if ((TWSR_REG & 0xF8)  != MASTER_WR_BYTE_ACK)
    22de:	81 b1       	in	r24, 0x01	; 1
    22e0:	88 7f       	andi	r24, 0xF8	; 248
    22e2:	88 32       	cpi	r24, 0x28	; 40
    22e4:	11 f4       	brne	.+4      	; 0x22ea <TWI_TWI_statusMasterSendData+0x1a>
	
}

TWI_status TWI_TWI_statusMasterSendData(u8 copy_u8data) {
	
	TWI_status LOC_TWI_statusVal=NOErr ;
    22e6:	80 e0       	ldi	r24, 0x00	; 0
    22e8:	08 95       	ret
	
	
	
	if ((TWSR_REG & 0xF8)  != MASTER_WR_BYTE_ACK)
	{
		LOC_TWI_statusVal=MasterSendDataErr ;
    22ea:	85 e0       	ldi	r24, 0x05	; 5
	}
	
	return LOC_TWI_statusVal ;
	
	
}
    22ec:	08 95       	ret

000022ee <TWI_TWI_statusMasterReciveData>:

TWI_status TWI_TWI_statusMasterReciveData(u8*copy_u8data){
    22ee:	fc 01       	movw	r30, r24
	
	
	TWI_status LOC_TWI_statusVal=NOErr ;
	/* CLR flag To send  save address  */
	SET_BIT(TWCR_REG,7) ;
    22f0:	96 b7       	in	r25, 0x36	; 54
    22f2:	90 68       	ori	r25, 0x80	; 128
    22f4:	96 bf       	out	0x36, r25	; 54
	
	/* WAIT TWI has finished  current job*/
	while(GET_BIT(TWCR_REG,7)==0);
    22f6:	06 b6       	in	r0, 0x36	; 54
    22f8:	07 fe       	sbrs	r0, 7
    22fa:	fd cf       	rjmp	.-6      	; 0x22f6 <TWI_TWI_statusMasterReciveData+0x8>
	
	
	
	if ((TWSR_REG & 0xF8) != MASTER_RD_BYTE_WITH_ACK)
    22fc:	91 b1       	in	r25, 0x01	; 1
    22fe:	98 7f       	andi	r25, 0xF8	; 248
    2300:	90 35       	cpi	r25, 0x50	; 80
    2302:	21 f4       	brne	.+8      	; 0x230c <TWI_TWI_statusMasterReciveData+0x1e>
	{
		LOC_TWI_statusVal=MasterReciveDataErr ;
	}
	else{
		   *copy_u8data=TWDR_REG ; 
    2304:	83 b1       	in	r24, 0x03	; 3
    2306:	80 83       	st	Z, r24
}

TWI_status TWI_TWI_statusMasterReciveData(u8*copy_u8data){
	
	
	TWI_status LOC_TWI_statusVal=NOErr ;
    2308:	80 e0       	ldi	r24, 0x00	; 0
    230a:	08 95       	ret
	
	
	
	if ((TWSR_REG & 0xF8) != MASTER_RD_BYTE_WITH_ACK)
	{
		LOC_TWI_statusVal=MasterReciveDataErr ;
    230c:	86 e0       	ldi	r24, 0x06	; 6
		   *copy_u8data=TWDR_REG ; 
	}
	
	return LOC_TWI_statusVal ;
	
}
    230e:	08 95       	ret

00002310 <TWI_voidStopCondition>:
void TWI_voidStopCondition(void){
	
	
	/* send stop condition */
	
	SET_BIT(TWCR_REG,4) ; 
    2310:	86 b7       	in	r24, 0x36	; 54
    2312:	80 61       	ori	r24, 0x10	; 16
    2314:	86 bf       	out	0x36, r24	; 54
	/* CLR flag To send  save address  */
	SET_BIT(TWCR_REG,7) ;
    2316:	86 b7       	in	r24, 0x36	; 54
    2318:	80 68       	ori	r24, 0x80	; 128
    231a:	86 bf       	out	0x36, r24	; 54
    231c:	08 95       	ret

0000231e <__subsf3>:
    231e:	50 58       	subi	r21, 0x80	; 128

00002320 <__addsf3>:
    2320:	bb 27       	eor	r27, r27
    2322:	aa 27       	eor	r26, r26
    2324:	0e 94 a7 11 	call	0x234e	; 0x234e <__addsf3x>
    2328:	0c 94 f1 12 	jmp	0x25e2	; 0x25e2 <__fp_round>
    232c:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <__fp_pscA>
    2330:	38 f0       	brcs	.+14     	; 0x2340 <__addsf3+0x20>
    2332:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <__fp_pscB>
    2336:	20 f0       	brcs	.+8      	; 0x2340 <__addsf3+0x20>
    2338:	39 f4       	brne	.+14     	; 0x2348 <__addsf3+0x28>
    233a:	9f 3f       	cpi	r25, 0xFF	; 255
    233c:	19 f4       	brne	.+6      	; 0x2344 <__addsf3+0x24>
    233e:	26 f4       	brtc	.+8      	; 0x2348 <__addsf3+0x28>
    2340:	0c 94 e0 12 	jmp	0x25c0	; 0x25c0 <__fp_nan>
    2344:	0e f4       	brtc	.+2      	; 0x2348 <__addsf3+0x28>
    2346:	e0 95       	com	r30
    2348:	e7 fb       	bst	r30, 7
    234a:	0c 94 da 12 	jmp	0x25b4	; 0x25b4 <__fp_inf>

0000234e <__addsf3x>:
    234e:	e9 2f       	mov	r30, r25
    2350:	0e 94 02 13 	call	0x2604	; 0x2604 <__fp_split3>
    2354:	58 f3       	brcs	.-42     	; 0x232c <__addsf3+0xc>
    2356:	ba 17       	cp	r27, r26
    2358:	62 07       	cpc	r22, r18
    235a:	73 07       	cpc	r23, r19
    235c:	84 07       	cpc	r24, r20
    235e:	95 07       	cpc	r25, r21
    2360:	20 f0       	brcs	.+8      	; 0x236a <__addsf3x+0x1c>
    2362:	79 f4       	brne	.+30     	; 0x2382 <__addsf3x+0x34>
    2364:	a6 f5       	brtc	.+104    	; 0x23ce <__addsf3x+0x80>
    2366:	0c 94 24 13 	jmp	0x2648	; 0x2648 <__fp_zero>
    236a:	0e f4       	brtc	.+2      	; 0x236e <__addsf3x+0x20>
    236c:	e0 95       	com	r30
    236e:	0b 2e       	mov	r0, r27
    2370:	ba 2f       	mov	r27, r26
    2372:	a0 2d       	mov	r26, r0
    2374:	0b 01       	movw	r0, r22
    2376:	b9 01       	movw	r22, r18
    2378:	90 01       	movw	r18, r0
    237a:	0c 01       	movw	r0, r24
    237c:	ca 01       	movw	r24, r20
    237e:	a0 01       	movw	r20, r0
    2380:	11 24       	eor	r1, r1
    2382:	ff 27       	eor	r31, r31
    2384:	59 1b       	sub	r21, r25
    2386:	99 f0       	breq	.+38     	; 0x23ae <__addsf3x+0x60>
    2388:	59 3f       	cpi	r21, 0xF9	; 249
    238a:	50 f4       	brcc	.+20     	; 0x23a0 <__addsf3x+0x52>
    238c:	50 3e       	cpi	r21, 0xE0	; 224
    238e:	68 f1       	brcs	.+90     	; 0x23ea <__addsf3x+0x9c>
    2390:	1a 16       	cp	r1, r26
    2392:	f0 40       	sbci	r31, 0x00	; 0
    2394:	a2 2f       	mov	r26, r18
    2396:	23 2f       	mov	r18, r19
    2398:	34 2f       	mov	r19, r20
    239a:	44 27       	eor	r20, r20
    239c:	58 5f       	subi	r21, 0xF8	; 248
    239e:	f3 cf       	rjmp	.-26     	; 0x2386 <__addsf3x+0x38>
    23a0:	46 95       	lsr	r20
    23a2:	37 95       	ror	r19
    23a4:	27 95       	ror	r18
    23a6:	a7 95       	ror	r26
    23a8:	f0 40       	sbci	r31, 0x00	; 0
    23aa:	53 95       	inc	r21
    23ac:	c9 f7       	brne	.-14     	; 0x23a0 <__addsf3x+0x52>
    23ae:	7e f4       	brtc	.+30     	; 0x23ce <__addsf3x+0x80>
    23b0:	1f 16       	cp	r1, r31
    23b2:	ba 0b       	sbc	r27, r26
    23b4:	62 0b       	sbc	r22, r18
    23b6:	73 0b       	sbc	r23, r19
    23b8:	84 0b       	sbc	r24, r20
    23ba:	ba f0       	brmi	.+46     	; 0x23ea <__addsf3x+0x9c>
    23bc:	91 50       	subi	r25, 0x01	; 1
    23be:	a1 f0       	breq	.+40     	; 0x23e8 <__addsf3x+0x9a>
    23c0:	ff 0f       	add	r31, r31
    23c2:	bb 1f       	adc	r27, r27
    23c4:	66 1f       	adc	r22, r22
    23c6:	77 1f       	adc	r23, r23
    23c8:	88 1f       	adc	r24, r24
    23ca:	c2 f7       	brpl	.-16     	; 0x23bc <__addsf3x+0x6e>
    23cc:	0e c0       	rjmp	.+28     	; 0x23ea <__addsf3x+0x9c>
    23ce:	ba 0f       	add	r27, r26
    23d0:	62 1f       	adc	r22, r18
    23d2:	73 1f       	adc	r23, r19
    23d4:	84 1f       	adc	r24, r20
    23d6:	48 f4       	brcc	.+18     	; 0x23ea <__addsf3x+0x9c>
    23d8:	87 95       	ror	r24
    23da:	77 95       	ror	r23
    23dc:	67 95       	ror	r22
    23de:	b7 95       	ror	r27
    23e0:	f7 95       	ror	r31
    23e2:	9e 3f       	cpi	r25, 0xFE	; 254
    23e4:	08 f0       	brcs	.+2      	; 0x23e8 <__addsf3x+0x9a>
    23e6:	b0 cf       	rjmp	.-160    	; 0x2348 <__addsf3+0x28>
    23e8:	93 95       	inc	r25
    23ea:	88 0f       	add	r24, r24
    23ec:	08 f0       	brcs	.+2      	; 0x23f0 <__addsf3x+0xa2>
    23ee:	99 27       	eor	r25, r25
    23f0:	ee 0f       	add	r30, r30
    23f2:	97 95       	ror	r25
    23f4:	87 95       	ror	r24
    23f6:	08 95       	ret

000023f8 <__divsf3>:
    23f8:	0e 94 10 12 	call	0x2420	; 0x2420 <__divsf3x>
    23fc:	0c 94 f1 12 	jmp	0x25e2	; 0x25e2 <__fp_round>
    2400:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <__fp_pscB>
    2404:	58 f0       	brcs	.+22     	; 0x241c <__divsf3+0x24>
    2406:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <__fp_pscA>
    240a:	40 f0       	brcs	.+16     	; 0x241c <__divsf3+0x24>
    240c:	29 f4       	brne	.+10     	; 0x2418 <__divsf3+0x20>
    240e:	5f 3f       	cpi	r21, 0xFF	; 255
    2410:	29 f0       	breq	.+10     	; 0x241c <__divsf3+0x24>
    2412:	0c 94 da 12 	jmp	0x25b4	; 0x25b4 <__fp_inf>
    2416:	51 11       	cpse	r21, r1
    2418:	0c 94 25 13 	jmp	0x264a	; 0x264a <__fp_szero>
    241c:	0c 94 e0 12 	jmp	0x25c0	; 0x25c0 <__fp_nan>

00002420 <__divsf3x>:
    2420:	0e 94 02 13 	call	0x2604	; 0x2604 <__fp_split3>
    2424:	68 f3       	brcs	.-38     	; 0x2400 <__divsf3+0x8>

00002426 <__divsf3_pse>:
    2426:	99 23       	and	r25, r25
    2428:	b1 f3       	breq	.-20     	; 0x2416 <__divsf3+0x1e>
    242a:	55 23       	and	r21, r21
    242c:	91 f3       	breq	.-28     	; 0x2412 <__divsf3+0x1a>
    242e:	95 1b       	sub	r25, r21
    2430:	55 0b       	sbc	r21, r21
    2432:	bb 27       	eor	r27, r27
    2434:	aa 27       	eor	r26, r26
    2436:	62 17       	cp	r22, r18
    2438:	73 07       	cpc	r23, r19
    243a:	84 07       	cpc	r24, r20
    243c:	38 f0       	brcs	.+14     	; 0x244c <__divsf3_pse+0x26>
    243e:	9f 5f       	subi	r25, 0xFF	; 255
    2440:	5f 4f       	sbci	r21, 0xFF	; 255
    2442:	22 0f       	add	r18, r18
    2444:	33 1f       	adc	r19, r19
    2446:	44 1f       	adc	r20, r20
    2448:	aa 1f       	adc	r26, r26
    244a:	a9 f3       	breq	.-22     	; 0x2436 <__divsf3_pse+0x10>
    244c:	35 d0       	rcall	.+106    	; 0x24b8 <__divsf3_pse+0x92>
    244e:	0e 2e       	mov	r0, r30
    2450:	3a f0       	brmi	.+14     	; 0x2460 <__divsf3_pse+0x3a>
    2452:	e0 e8       	ldi	r30, 0x80	; 128
    2454:	32 d0       	rcall	.+100    	; 0x24ba <__divsf3_pse+0x94>
    2456:	91 50       	subi	r25, 0x01	; 1
    2458:	50 40       	sbci	r21, 0x00	; 0
    245a:	e6 95       	lsr	r30
    245c:	00 1c       	adc	r0, r0
    245e:	ca f7       	brpl	.-14     	; 0x2452 <__divsf3_pse+0x2c>
    2460:	2b d0       	rcall	.+86     	; 0x24b8 <__divsf3_pse+0x92>
    2462:	fe 2f       	mov	r31, r30
    2464:	29 d0       	rcall	.+82     	; 0x24b8 <__divsf3_pse+0x92>
    2466:	66 0f       	add	r22, r22
    2468:	77 1f       	adc	r23, r23
    246a:	88 1f       	adc	r24, r24
    246c:	bb 1f       	adc	r27, r27
    246e:	26 17       	cp	r18, r22
    2470:	37 07       	cpc	r19, r23
    2472:	48 07       	cpc	r20, r24
    2474:	ab 07       	cpc	r26, r27
    2476:	b0 e8       	ldi	r27, 0x80	; 128
    2478:	09 f0       	breq	.+2      	; 0x247c <__divsf3_pse+0x56>
    247a:	bb 0b       	sbc	r27, r27
    247c:	80 2d       	mov	r24, r0
    247e:	bf 01       	movw	r22, r30
    2480:	ff 27       	eor	r31, r31
    2482:	93 58       	subi	r25, 0x83	; 131
    2484:	5f 4f       	sbci	r21, 0xFF	; 255
    2486:	3a f0       	brmi	.+14     	; 0x2496 <__divsf3_pse+0x70>
    2488:	9e 3f       	cpi	r25, 0xFE	; 254
    248a:	51 05       	cpc	r21, r1
    248c:	78 f0       	brcs	.+30     	; 0x24ac <__divsf3_pse+0x86>
    248e:	0c 94 da 12 	jmp	0x25b4	; 0x25b4 <__fp_inf>
    2492:	0c 94 25 13 	jmp	0x264a	; 0x264a <__fp_szero>
    2496:	5f 3f       	cpi	r21, 0xFF	; 255
    2498:	e4 f3       	brlt	.-8      	; 0x2492 <__divsf3_pse+0x6c>
    249a:	98 3e       	cpi	r25, 0xE8	; 232
    249c:	d4 f3       	brlt	.-12     	; 0x2492 <__divsf3_pse+0x6c>
    249e:	86 95       	lsr	r24
    24a0:	77 95       	ror	r23
    24a2:	67 95       	ror	r22
    24a4:	b7 95       	ror	r27
    24a6:	f7 95       	ror	r31
    24a8:	9f 5f       	subi	r25, 0xFF	; 255
    24aa:	c9 f7       	brne	.-14     	; 0x249e <__divsf3_pse+0x78>
    24ac:	88 0f       	add	r24, r24
    24ae:	91 1d       	adc	r25, r1
    24b0:	96 95       	lsr	r25
    24b2:	87 95       	ror	r24
    24b4:	97 f9       	bld	r25, 7
    24b6:	08 95       	ret
    24b8:	e1 e0       	ldi	r30, 0x01	; 1
    24ba:	66 0f       	add	r22, r22
    24bc:	77 1f       	adc	r23, r23
    24be:	88 1f       	adc	r24, r24
    24c0:	bb 1f       	adc	r27, r27
    24c2:	62 17       	cp	r22, r18
    24c4:	73 07       	cpc	r23, r19
    24c6:	84 07       	cpc	r24, r20
    24c8:	ba 07       	cpc	r27, r26
    24ca:	20 f0       	brcs	.+8      	; 0x24d4 <__divsf3_pse+0xae>
    24cc:	62 1b       	sub	r22, r18
    24ce:	73 0b       	sbc	r23, r19
    24d0:	84 0b       	sbc	r24, r20
    24d2:	ba 0b       	sbc	r27, r26
    24d4:	ee 1f       	adc	r30, r30
    24d6:	88 f7       	brcc	.-30     	; 0x24ba <__divsf3_pse+0x94>
    24d8:	e0 95       	com	r30
    24da:	08 95       	ret

000024dc <__fixunssfsi>:
    24dc:	0e 94 0a 13 	call	0x2614	; 0x2614 <__fp_splitA>
    24e0:	88 f0       	brcs	.+34     	; 0x2504 <__fixunssfsi+0x28>
    24e2:	9f 57       	subi	r25, 0x7F	; 127
    24e4:	98 f0       	brcs	.+38     	; 0x250c <__fixunssfsi+0x30>
    24e6:	b9 2f       	mov	r27, r25
    24e8:	99 27       	eor	r25, r25
    24ea:	b7 51       	subi	r27, 0x17	; 23
    24ec:	b0 f0       	brcs	.+44     	; 0x251a <__fixunssfsi+0x3e>
    24ee:	e1 f0       	breq	.+56     	; 0x2528 <__fixunssfsi+0x4c>
    24f0:	66 0f       	add	r22, r22
    24f2:	77 1f       	adc	r23, r23
    24f4:	88 1f       	adc	r24, r24
    24f6:	99 1f       	adc	r25, r25
    24f8:	1a f0       	brmi	.+6      	; 0x2500 <__fixunssfsi+0x24>
    24fa:	ba 95       	dec	r27
    24fc:	c9 f7       	brne	.-14     	; 0x24f0 <__fixunssfsi+0x14>
    24fe:	14 c0       	rjmp	.+40     	; 0x2528 <__fixunssfsi+0x4c>
    2500:	b1 30       	cpi	r27, 0x01	; 1
    2502:	91 f0       	breq	.+36     	; 0x2528 <__fixunssfsi+0x4c>
    2504:	0e 94 24 13 	call	0x2648	; 0x2648 <__fp_zero>
    2508:	b1 e0       	ldi	r27, 0x01	; 1
    250a:	08 95       	ret
    250c:	0c 94 24 13 	jmp	0x2648	; 0x2648 <__fp_zero>
    2510:	67 2f       	mov	r22, r23
    2512:	78 2f       	mov	r23, r24
    2514:	88 27       	eor	r24, r24
    2516:	b8 5f       	subi	r27, 0xF8	; 248
    2518:	39 f0       	breq	.+14     	; 0x2528 <__fixunssfsi+0x4c>
    251a:	b9 3f       	cpi	r27, 0xF9	; 249
    251c:	cc f3       	brlt	.-14     	; 0x2510 <__fixunssfsi+0x34>
    251e:	86 95       	lsr	r24
    2520:	77 95       	ror	r23
    2522:	67 95       	ror	r22
    2524:	b3 95       	inc	r27
    2526:	d9 f7       	brne	.-10     	; 0x251e <__fixunssfsi+0x42>
    2528:	3e f4       	brtc	.+14     	; 0x2538 <__fixunssfsi+0x5c>
    252a:	90 95       	com	r25
    252c:	80 95       	com	r24
    252e:	70 95       	com	r23
    2530:	61 95       	neg	r22
    2532:	7f 4f       	sbci	r23, 0xFF	; 255
    2534:	8f 4f       	sbci	r24, 0xFF	; 255
    2536:	9f 4f       	sbci	r25, 0xFF	; 255
    2538:	08 95       	ret

0000253a <__floatunsisf>:
    253a:	e8 94       	clt
    253c:	09 c0       	rjmp	.+18     	; 0x2550 <__floatsisf+0x12>

0000253e <__floatsisf>:
    253e:	97 fb       	bst	r25, 7
    2540:	3e f4       	brtc	.+14     	; 0x2550 <__floatsisf+0x12>
    2542:	90 95       	com	r25
    2544:	80 95       	com	r24
    2546:	70 95       	com	r23
    2548:	61 95       	neg	r22
    254a:	7f 4f       	sbci	r23, 0xFF	; 255
    254c:	8f 4f       	sbci	r24, 0xFF	; 255
    254e:	9f 4f       	sbci	r25, 0xFF	; 255
    2550:	99 23       	and	r25, r25
    2552:	a9 f0       	breq	.+42     	; 0x257e <__floatsisf+0x40>
    2554:	f9 2f       	mov	r31, r25
    2556:	96 e9       	ldi	r25, 0x96	; 150
    2558:	bb 27       	eor	r27, r27
    255a:	93 95       	inc	r25
    255c:	f6 95       	lsr	r31
    255e:	87 95       	ror	r24
    2560:	77 95       	ror	r23
    2562:	67 95       	ror	r22
    2564:	b7 95       	ror	r27
    2566:	f1 11       	cpse	r31, r1
    2568:	f8 cf       	rjmp	.-16     	; 0x255a <__floatsisf+0x1c>
    256a:	fa f4       	brpl	.+62     	; 0x25aa <__floatsisf+0x6c>
    256c:	bb 0f       	add	r27, r27
    256e:	11 f4       	brne	.+4      	; 0x2574 <__floatsisf+0x36>
    2570:	60 ff       	sbrs	r22, 0
    2572:	1b c0       	rjmp	.+54     	; 0x25aa <__floatsisf+0x6c>
    2574:	6f 5f       	subi	r22, 0xFF	; 255
    2576:	7f 4f       	sbci	r23, 0xFF	; 255
    2578:	8f 4f       	sbci	r24, 0xFF	; 255
    257a:	9f 4f       	sbci	r25, 0xFF	; 255
    257c:	16 c0       	rjmp	.+44     	; 0x25aa <__floatsisf+0x6c>
    257e:	88 23       	and	r24, r24
    2580:	11 f0       	breq	.+4      	; 0x2586 <__floatsisf+0x48>
    2582:	96 e9       	ldi	r25, 0x96	; 150
    2584:	11 c0       	rjmp	.+34     	; 0x25a8 <__floatsisf+0x6a>
    2586:	77 23       	and	r23, r23
    2588:	21 f0       	breq	.+8      	; 0x2592 <__floatsisf+0x54>
    258a:	9e e8       	ldi	r25, 0x8E	; 142
    258c:	87 2f       	mov	r24, r23
    258e:	76 2f       	mov	r23, r22
    2590:	05 c0       	rjmp	.+10     	; 0x259c <__floatsisf+0x5e>
    2592:	66 23       	and	r22, r22
    2594:	71 f0       	breq	.+28     	; 0x25b2 <__floatsisf+0x74>
    2596:	96 e8       	ldi	r25, 0x86	; 134
    2598:	86 2f       	mov	r24, r22
    259a:	70 e0       	ldi	r23, 0x00	; 0
    259c:	60 e0       	ldi	r22, 0x00	; 0
    259e:	2a f0       	brmi	.+10     	; 0x25aa <__floatsisf+0x6c>
    25a0:	9a 95       	dec	r25
    25a2:	66 0f       	add	r22, r22
    25a4:	77 1f       	adc	r23, r23
    25a6:	88 1f       	adc	r24, r24
    25a8:	da f7       	brpl	.-10     	; 0x25a0 <__floatsisf+0x62>
    25aa:	88 0f       	add	r24, r24
    25ac:	96 95       	lsr	r25
    25ae:	87 95       	ror	r24
    25b0:	97 f9       	bld	r25, 7
    25b2:	08 95       	ret

000025b4 <__fp_inf>:
    25b4:	97 f9       	bld	r25, 7
    25b6:	9f 67       	ori	r25, 0x7F	; 127
    25b8:	80 e8       	ldi	r24, 0x80	; 128
    25ba:	70 e0       	ldi	r23, 0x00	; 0
    25bc:	60 e0       	ldi	r22, 0x00	; 0
    25be:	08 95       	ret

000025c0 <__fp_nan>:
    25c0:	9f ef       	ldi	r25, 0xFF	; 255
    25c2:	80 ec       	ldi	r24, 0xC0	; 192
    25c4:	08 95       	ret

000025c6 <__fp_pscA>:
    25c6:	00 24       	eor	r0, r0
    25c8:	0a 94       	dec	r0
    25ca:	16 16       	cp	r1, r22
    25cc:	17 06       	cpc	r1, r23
    25ce:	18 06       	cpc	r1, r24
    25d0:	09 06       	cpc	r0, r25
    25d2:	08 95       	ret

000025d4 <__fp_pscB>:
    25d4:	00 24       	eor	r0, r0
    25d6:	0a 94       	dec	r0
    25d8:	12 16       	cp	r1, r18
    25da:	13 06       	cpc	r1, r19
    25dc:	14 06       	cpc	r1, r20
    25de:	05 06       	cpc	r0, r21
    25e0:	08 95       	ret

000025e2 <__fp_round>:
    25e2:	09 2e       	mov	r0, r25
    25e4:	03 94       	inc	r0
    25e6:	00 0c       	add	r0, r0
    25e8:	11 f4       	brne	.+4      	; 0x25ee <__fp_round+0xc>
    25ea:	88 23       	and	r24, r24
    25ec:	52 f0       	brmi	.+20     	; 0x2602 <__fp_round+0x20>
    25ee:	bb 0f       	add	r27, r27
    25f0:	40 f4       	brcc	.+16     	; 0x2602 <__fp_round+0x20>
    25f2:	bf 2b       	or	r27, r31
    25f4:	11 f4       	brne	.+4      	; 0x25fa <__fp_round+0x18>
    25f6:	60 ff       	sbrs	r22, 0
    25f8:	04 c0       	rjmp	.+8      	; 0x2602 <__fp_round+0x20>
    25fa:	6f 5f       	subi	r22, 0xFF	; 255
    25fc:	7f 4f       	sbci	r23, 0xFF	; 255
    25fe:	8f 4f       	sbci	r24, 0xFF	; 255
    2600:	9f 4f       	sbci	r25, 0xFF	; 255
    2602:	08 95       	ret

00002604 <__fp_split3>:
    2604:	57 fd       	sbrc	r21, 7
    2606:	90 58       	subi	r25, 0x80	; 128
    2608:	44 0f       	add	r20, r20
    260a:	55 1f       	adc	r21, r21
    260c:	59 f0       	breq	.+22     	; 0x2624 <__fp_splitA+0x10>
    260e:	5f 3f       	cpi	r21, 0xFF	; 255
    2610:	71 f0       	breq	.+28     	; 0x262e <__fp_splitA+0x1a>
    2612:	47 95       	ror	r20

00002614 <__fp_splitA>:
    2614:	88 0f       	add	r24, r24
    2616:	97 fb       	bst	r25, 7
    2618:	99 1f       	adc	r25, r25
    261a:	61 f0       	breq	.+24     	; 0x2634 <__fp_splitA+0x20>
    261c:	9f 3f       	cpi	r25, 0xFF	; 255
    261e:	79 f0       	breq	.+30     	; 0x263e <__fp_splitA+0x2a>
    2620:	87 95       	ror	r24
    2622:	08 95       	ret
    2624:	12 16       	cp	r1, r18
    2626:	13 06       	cpc	r1, r19
    2628:	14 06       	cpc	r1, r20
    262a:	55 1f       	adc	r21, r21
    262c:	f2 cf       	rjmp	.-28     	; 0x2612 <__fp_split3+0xe>
    262e:	46 95       	lsr	r20
    2630:	f1 df       	rcall	.-30     	; 0x2614 <__fp_splitA>
    2632:	08 c0       	rjmp	.+16     	; 0x2644 <__fp_splitA+0x30>
    2634:	16 16       	cp	r1, r22
    2636:	17 06       	cpc	r1, r23
    2638:	18 06       	cpc	r1, r24
    263a:	99 1f       	adc	r25, r25
    263c:	f1 cf       	rjmp	.-30     	; 0x2620 <__fp_splitA+0xc>
    263e:	86 95       	lsr	r24
    2640:	71 05       	cpc	r23, r1
    2642:	61 05       	cpc	r22, r1
    2644:	08 94       	sec
    2646:	08 95       	ret

00002648 <__fp_zero>:
    2648:	e8 94       	clt

0000264a <__fp_szero>:
    264a:	bb 27       	eor	r27, r27
    264c:	66 27       	eor	r22, r22
    264e:	77 27       	eor	r23, r23
    2650:	cb 01       	movw	r24, r22
    2652:	97 f9       	bld	r25, 7
    2654:	08 95       	ret

00002656 <__mulsf3>:
    2656:	0e 94 3e 13 	call	0x267c	; 0x267c <__mulsf3x>
    265a:	0c 94 f1 12 	jmp	0x25e2	; 0x25e2 <__fp_round>
    265e:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <__fp_pscA>
    2662:	38 f0       	brcs	.+14     	; 0x2672 <__mulsf3+0x1c>
    2664:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <__fp_pscB>
    2668:	20 f0       	brcs	.+8      	; 0x2672 <__mulsf3+0x1c>
    266a:	95 23       	and	r25, r21
    266c:	11 f0       	breq	.+4      	; 0x2672 <__mulsf3+0x1c>
    266e:	0c 94 da 12 	jmp	0x25b4	; 0x25b4 <__fp_inf>
    2672:	0c 94 e0 12 	jmp	0x25c0	; 0x25c0 <__fp_nan>
    2676:	11 24       	eor	r1, r1
    2678:	0c 94 25 13 	jmp	0x264a	; 0x264a <__fp_szero>

0000267c <__mulsf3x>:
    267c:	0e 94 02 13 	call	0x2604	; 0x2604 <__fp_split3>
    2680:	70 f3       	brcs	.-36     	; 0x265e <__mulsf3+0x8>

00002682 <__mulsf3_pse>:
    2682:	95 9f       	mul	r25, r21
    2684:	c1 f3       	breq	.-16     	; 0x2676 <__mulsf3+0x20>
    2686:	95 0f       	add	r25, r21
    2688:	50 e0       	ldi	r21, 0x00	; 0
    268a:	55 1f       	adc	r21, r21
    268c:	62 9f       	mul	r22, r18
    268e:	f0 01       	movw	r30, r0
    2690:	72 9f       	mul	r23, r18
    2692:	bb 27       	eor	r27, r27
    2694:	f0 0d       	add	r31, r0
    2696:	b1 1d       	adc	r27, r1
    2698:	63 9f       	mul	r22, r19
    269a:	aa 27       	eor	r26, r26
    269c:	f0 0d       	add	r31, r0
    269e:	b1 1d       	adc	r27, r1
    26a0:	aa 1f       	adc	r26, r26
    26a2:	64 9f       	mul	r22, r20
    26a4:	66 27       	eor	r22, r22
    26a6:	b0 0d       	add	r27, r0
    26a8:	a1 1d       	adc	r26, r1
    26aa:	66 1f       	adc	r22, r22
    26ac:	82 9f       	mul	r24, r18
    26ae:	22 27       	eor	r18, r18
    26b0:	b0 0d       	add	r27, r0
    26b2:	a1 1d       	adc	r26, r1
    26b4:	62 1f       	adc	r22, r18
    26b6:	73 9f       	mul	r23, r19
    26b8:	b0 0d       	add	r27, r0
    26ba:	a1 1d       	adc	r26, r1
    26bc:	62 1f       	adc	r22, r18
    26be:	83 9f       	mul	r24, r19
    26c0:	a0 0d       	add	r26, r0
    26c2:	61 1d       	adc	r22, r1
    26c4:	22 1f       	adc	r18, r18
    26c6:	74 9f       	mul	r23, r20
    26c8:	33 27       	eor	r19, r19
    26ca:	a0 0d       	add	r26, r0
    26cc:	61 1d       	adc	r22, r1
    26ce:	23 1f       	adc	r18, r19
    26d0:	84 9f       	mul	r24, r20
    26d2:	60 0d       	add	r22, r0
    26d4:	21 1d       	adc	r18, r1
    26d6:	82 2f       	mov	r24, r18
    26d8:	76 2f       	mov	r23, r22
    26da:	6a 2f       	mov	r22, r26
    26dc:	11 24       	eor	r1, r1
    26de:	9f 57       	subi	r25, 0x7F	; 127
    26e0:	50 40       	sbci	r21, 0x00	; 0
    26e2:	9a f0       	brmi	.+38     	; 0x270a <__mulsf3_pse+0x88>
    26e4:	f1 f0       	breq	.+60     	; 0x2722 <__mulsf3_pse+0xa0>
    26e6:	88 23       	and	r24, r24
    26e8:	4a f0       	brmi	.+18     	; 0x26fc <__mulsf3_pse+0x7a>
    26ea:	ee 0f       	add	r30, r30
    26ec:	ff 1f       	adc	r31, r31
    26ee:	bb 1f       	adc	r27, r27
    26f0:	66 1f       	adc	r22, r22
    26f2:	77 1f       	adc	r23, r23
    26f4:	88 1f       	adc	r24, r24
    26f6:	91 50       	subi	r25, 0x01	; 1
    26f8:	50 40       	sbci	r21, 0x00	; 0
    26fa:	a9 f7       	brne	.-22     	; 0x26e6 <__mulsf3_pse+0x64>
    26fc:	9e 3f       	cpi	r25, 0xFE	; 254
    26fe:	51 05       	cpc	r21, r1
    2700:	80 f0       	brcs	.+32     	; 0x2722 <__mulsf3_pse+0xa0>
    2702:	0c 94 da 12 	jmp	0x25b4	; 0x25b4 <__fp_inf>
    2706:	0c 94 25 13 	jmp	0x264a	; 0x264a <__fp_szero>
    270a:	5f 3f       	cpi	r21, 0xFF	; 255
    270c:	e4 f3       	brlt	.-8      	; 0x2706 <__mulsf3_pse+0x84>
    270e:	98 3e       	cpi	r25, 0xE8	; 232
    2710:	d4 f3       	brlt	.-12     	; 0x2706 <__mulsf3_pse+0x84>
    2712:	86 95       	lsr	r24
    2714:	77 95       	ror	r23
    2716:	67 95       	ror	r22
    2718:	b7 95       	ror	r27
    271a:	f7 95       	ror	r31
    271c:	e7 95       	ror	r30
    271e:	9f 5f       	subi	r25, 0xFF	; 255
    2720:	c1 f7       	brne	.-16     	; 0x2712 <__mulsf3_pse+0x90>
    2722:	fe 2b       	or	r31, r30
    2724:	88 0f       	add	r24, r24
    2726:	91 1d       	adc	r25, r1
    2728:	96 95       	lsr	r25
    272a:	87 95       	ror	r24
    272c:	97 f9       	bld	r25, 7
    272e:	08 95       	ret

00002730 <__udivmodsi4>:
    2730:	a1 e2       	ldi	r26, 0x21	; 33
    2732:	1a 2e       	mov	r1, r26
    2734:	aa 1b       	sub	r26, r26
    2736:	bb 1b       	sub	r27, r27
    2738:	fd 01       	movw	r30, r26
    273a:	0d c0       	rjmp	.+26     	; 0x2756 <__udivmodsi4_ep>

0000273c <__udivmodsi4_loop>:
    273c:	aa 1f       	adc	r26, r26
    273e:	bb 1f       	adc	r27, r27
    2740:	ee 1f       	adc	r30, r30
    2742:	ff 1f       	adc	r31, r31
    2744:	a2 17       	cp	r26, r18
    2746:	b3 07       	cpc	r27, r19
    2748:	e4 07       	cpc	r30, r20
    274a:	f5 07       	cpc	r31, r21
    274c:	20 f0       	brcs	.+8      	; 0x2756 <__udivmodsi4_ep>
    274e:	a2 1b       	sub	r26, r18
    2750:	b3 0b       	sbc	r27, r19
    2752:	e4 0b       	sbc	r30, r20
    2754:	f5 0b       	sbc	r31, r21

00002756 <__udivmodsi4_ep>:
    2756:	66 1f       	adc	r22, r22
    2758:	77 1f       	adc	r23, r23
    275a:	88 1f       	adc	r24, r24
    275c:	99 1f       	adc	r25, r25
    275e:	1a 94       	dec	r1
    2760:	69 f7       	brne	.-38     	; 0x273c <__udivmodsi4_loop>
    2762:	60 95       	com	r22
    2764:	70 95       	com	r23
    2766:	80 95       	com	r24
    2768:	90 95       	com	r25
    276a:	9b 01       	movw	r18, r22
    276c:	ac 01       	movw	r20, r24
    276e:	bd 01       	movw	r22, r26
    2770:	cf 01       	movw	r24, r30
    2772:	08 95       	ret

00002774 <memcpy>:
    2774:	fb 01       	movw	r30, r22
    2776:	dc 01       	movw	r26, r24
    2778:	02 c0       	rjmp	.+4      	; 0x277e <memcpy+0xa>
    277a:	01 90       	ld	r0, Z+
    277c:	0d 92       	st	X+, r0
    277e:	41 50       	subi	r20, 0x01	; 1
    2780:	50 40       	sbci	r21, 0x00	; 0
    2782:	d8 f7       	brcc	.-10     	; 0x277a <memcpy+0x6>
    2784:	08 95       	ret

00002786 <_exit>:
    2786:	f8 94       	cli

00002788 <__stop_program>:
    2788:	ff cf       	rjmp	.-2      	; 0x2788 <__stop_program>
